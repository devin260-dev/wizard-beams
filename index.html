<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wizard Beams</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a1a;
            font-family: 'Georgia', serif;
        }

        #gameCanvas {
            display: block;
        }

        #controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 15px;
            z-index: 10;
        }

        .spell-btn {
            padding: 20px 40px;
            font-size: 24px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .spell-btn:hover:not(:disabled) {
            transform: scale(1.1);
        }

        .spell-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #spiralBtn {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
            box-shadow: 0 0 20px rgba(155, 89, 182, 0.5);
        }

        #pulseBtn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
        }

        #zapBtn {
            background: linear-gradient(135deg, #f1c40f, #f39c12);
            color: #333;
            box-shadow: 0 0 20px rgba(241, 196, 15, 0.5);
        }

        #neutralBtn {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            color: white;
            box-shadow: 0 0 20px rgba(149, 165, 166, 0.5);
        }

        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
        }

        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 30px currentColor;
        }

        #gameOver.win h1 {
            color: #2ecc71;
        }

        #gameOver.lose h1 {
            color: #e74c3c;
        }

        #restartBtn {
            padding: 15px 40px;
            font-size: 24px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #restartBtn:hover {
            transform: scale(1.1);
        }

        #clashResult {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: white;
            text-shadow: 0 0 20px white;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 50;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="controls">
        <button id="neutralBtn" class="spell-btn">Neutral</button>
        <button id="spiralBtn" class="spell-btn">Spiral</button>
        <button id="pulseBtn" class="spell-btn">Pulse</button>
        <button id="zapBtn" class="spell-btn">Zap</button>
    </div>

    <div id="clashResult"></div>

    <div id="gameOver">
        <h1 id="gameOverText"></h1>
        <button id="restartBtn">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const neutralBtn = document.getElementById('neutralBtn');
        const spiralBtn = document.getElementById('spiralBtn');
        const pulseBtn = document.getElementById('pulseBtn');
        const zapBtn = document.getElementById('zapBtn');
        const gameOverScreen = document.getElementById('gameOver');
        const gameOverText = document.getElementById('gameOverText');
        const restartBtn = document.getElementById('restartBtn');
        const clashResult = document.getElementById('clashResult');

        // Game state
        let ballPosition = 50; // 0-100, starts at center
        let playerChoice = 'neutral'; // Start with Neutral as default (safe, no modifier)
        let lastClashTime = 0;
        let clashInterval = 2000; // 2 seconds
        let gameActive = true;
        let animationTime = 0;

        // Enemy AI state (sticky random)
        let enemyCurrentBeam = null;
        let enemyClashesRemaining = 0;

        // Collision effects
        let particles = [];
        let clashFlashIntensity = 0;
        let lastClashResult = 0; // -1, 0, or 1

        // Stick figure node system
        const stickFigure = {
            centerX: 0,  // Will be set based on canvas width
            centerY: 0,  // Will be set based on canvas height
            scale: 1,
            // Node positions relative to center (torso center)
            nodeOffsets: {
                head: { x: 0, y: -70 },
                center: { x: 0, y: 0 },
                leftHand: { x: -60, y: -20 },
                rightHand: { x: 60, y: -20 },
                leftFoot: { x: -25, y: 70 },
                rightFoot: { x: 25, y: 70 }
            },
            nodeRadius: 12,
            nodes: {} // Will hold spell assignments
        };

        // Stick figure awareness state
        let stickAwarenessPos = { x: 0, y: 0 };
        let stickAwarenessAtNode = 'center';
        let stickAwarenessTarget = 'center';
        let stickAwarenessMoving = false;
        let stickAwarenessMoveStartTime = 0;
        let stickAwarenessMoveStartPos = { x: 0, y: 0 };
        const stickAwarenessMoveTime = 1000; // 1 second travel time

        // Node activation state
        // States: 'dormant', 'activating', 'active'
        let nodeStates = {};
        let nodeActivationProgress = {}; // 0 to 1 for activating nodes
        let nodeActivationStartTime = {};
        const nodeActivationTime = 2000; // 2 seconds to activate

        // Active mana counters
        let playerActiveMana = 0;
        const enemyActiveMana = 3; // Fixed value for now

        // Beam type commitment system
        let playerBeamType = null; // Currently committed beam type
        let enemyBeamType = null; // Enemy's current beam type
        let enemyBeamSwitchTime = 0; // When enemy will switch beams
        const enemyBeamDuration = 4000 + Math.random() * 4000; // 4-8 seconds between switches
        const counterBonus = 3; // +3 or -3 based on counter

        // Cooldown system
        let cooldowns = {
            neutral: 0,
            spiral: 0,
            pulse: 0,
            zap: 0
        };
        const cooldownDuration = 5000; // 5 seconds commitment

        // Beam thickness based on mana (0-6 mana maps to min-max thickness)
        const BEAM_THICKNESS_MIN = 8;
        const BEAM_THICKNESS_MAX = 45;

        function getBeamThickness(mana) {
            // Clamp mana to 0-6 range
            const clampedMana = Math.max(0, Math.min(6, mana));
            // Linear interpolation from min to max
            return BEAM_THICKNESS_MIN + (clampedMana / 6) * (BEAM_THICKNESS_MAX - BEAM_THICKNESS_MIN);
        }

        // Rock-paper-scissors: returns 1 if a beats b, -1 if b beats a, 0 if tie/neutral
        function getCounterResult(a, b) {
            // Neutral always gives 0 modifier (no bonus, no penalty)
            if (a === NEUTRAL || b === NEUTRAL) return 0;
            if (a === b) return 0;
            if ((a === SPIRAL && b === ZAP) ||
                (a === ZAP && b === PULSE) ||
                (a === PULSE && b === SPIRAL)) {
                return 1; // a beats b
            }
            return -1; // b beats a
        }

        // Get counter modifier for player
        function getCounterModifier() {
            if (!playerBeamType || !enemyBeamType) return 0;
            const result = getCounterResult(playerBeamType, enemyBeamType);
            return result * counterBonus; // +3 if countering, -3 if countered, 0 if tie
        }

        // Initialize node states (all dormant)
        function initNodeStates() {
            const nodeNames = ['head', 'center', 'leftHand', 'rightHand', 'leftFoot', 'rightFoot'];
            nodeStates = {};
            nodeActivationProgress = {};
            nodeActivationStartTime = {};
            playerActiveMana = 0;
            nodeNames.forEach(name => {
                nodeStates[name] = 'dormant';
                nodeActivationProgress[name] = 0;
            });
        }

        // Start activating a node (called when awareness arrives)
        function startNodeActivation(nodeName) {
            if (nodeStates[nodeName] === 'dormant') {
                nodeStates[nodeName] = 'activating';
                nodeActivationStartTime[nodeName] = performance.now();
                nodeActivationProgress[nodeName] = 0;
            }
            // If already activating or active, do nothing
        }

        // Update node activation progress (call each frame)
        function updateNodeActivation(timestamp) {
            const nodeNames = ['head', 'center', 'leftHand', 'rightHand', 'leftFoot', 'rightFoot'];
            nodeNames.forEach(nodeName => {
                if (nodeStates[nodeName] === 'activating') {
                    // Only progress if awareness is at this node
                    if (stickAwarenessAtNode === nodeName) {
                        const elapsed = timestamp - nodeActivationStartTime[nodeName];
                        nodeActivationProgress[nodeName] = Math.min(1, elapsed / nodeActivationTime);

                        if (nodeActivationProgress[nodeName] >= 1) {
                            nodeStates[nodeName] = 'active';
                            playerActiveMana = Math.min(6, playerActiveMana + 1);
                        }
                    }
                }
            });
        }

        // Initialize stick figure nodes with random spell assignments
        function initStickFigureNodes() {
            const nodeNames = ['head', 'center', 'leftHand', 'rightHand', 'leftFoot', 'rightFoot'];
            const spells = [SPIRAL, PULSE, ZAP]; // 3 spells

            // Shuffle node names
            const shuffledNodes = [...nodeNames].sort(() => Math.random() - 0.5);

            // First 3 get spells, rest are duds
            stickFigure.nodes = {};
            shuffledNodes.forEach((nodeName, index) => {
                if (index < 3) {
                    stickFigure.nodes[nodeName] = spells[index];
                } else {
                    stickFigure.nodes[nodeName] = 'dud';
                }
            });
        }

        // Get color for a node
        function getNodeColor(nodeName) {
            const spell = stickFigure.nodes[nodeName];
            if (spell === 'dud') return '#666666'; // Grey for duds
            return colors[spell] || '#666666';
        }

        // Get stick figure node world position
        function getStickNodePosition(nodeName) {
            const offset = stickFigure.nodeOffsets[nodeName];
            return {
                x: stickFigure.centerX + offset.x * stickFigure.scale,
                y: stickFigure.centerY + offset.y * stickFigure.scale
            };
        }

        // Initialize stick figure awareness at center node
        function initStickAwareness() {
            stickAwarenessAtNode = 'center';
            stickAwarenessTarget = 'center';
            stickAwarenessMoving = false;
            // Position will be set properly once stickFigure.centerX/Y are calculated
            // Start activating the center node since awareness begins there
            startNodeActivation('center');
        }

        // Update stick figure awareness position (call each frame)
        function updateStickAwareness(timestamp) {
            // Make sure stick figure position is set
            stickFigure.centerX = canvas.width / 2;
            stickFigure.centerY = canvas.height - 100;

            if (stickAwarenessMoving) {
                const elapsed = timestamp - stickAwarenessMoveStartTime;
                const progress = Math.min(1, elapsed / stickAwarenessMoveTime);
                // Ease out cubic for smooth deceleration
                const eased = 1 - Math.pow(1 - progress, 3);

                const targetPos = getStickNodePosition(stickAwarenessTarget);
                stickAwarenessPos.x = stickAwarenessMoveStartPos.x + (targetPos.x - stickAwarenessMoveStartPos.x) * eased;
                stickAwarenessPos.y = stickAwarenessMoveStartPos.y + (targetPos.y - stickAwarenessMoveStartPos.y) * eased;

                if (progress >= 1) {
                    stickAwarenessMoving = false;
                    stickAwarenessAtNode = stickAwarenessTarget;
                    stickAwarenessPos = { ...targetPos };
                    // Start activating this node when awareness arrives
                    startNodeActivation(stickAwarenessAtNode);
                }
            } else {
                // Snap to current node position (in case canvas resized)
                const currentPos = getStickNodePosition(stickAwarenessAtNode);
                stickAwarenessPos = { ...currentPos };
            }
        }

        // Move stick figure awareness to a different node
        function moveStickAwarenessTo(nodeName) {
            if (stickAwarenessMoving) return; // Can't move while already moving
            if (stickAwarenessAtNode === nodeName) return; // Already there

            stickAwarenessTarget = nodeName;
            stickAwarenessMoving = true;
            stickAwarenessMoveStartTime = performance.now();
            stickAwarenessMoveStartPos = { ...stickAwarenessPos };
            stickAwarenessAtNode = null; // In transit
        }

        // Check if a click hit a stick figure node
        function getClickedStickNode(clickX, clickY) {
            const nodeNames = ['head', 'center', 'leftHand', 'rightHand', 'leftFoot', 'rightFoot'];
            for (const nodeName of nodeNames) {
                const pos = getStickNodePosition(nodeName);
                const dist = Math.sqrt(Math.pow(clickX - pos.x, 2) + Math.pow(clickY - pos.y, 2));
                if (dist <= stickFigure.nodeRadius + 10) {
                    return nodeName;
                }
            }
            return null;
        }

        // Draw the stick figure with nodes
        function drawStickFigure() {
            // Position stick figure at bottom center of screen
            stickFigure.centerX = canvas.width / 2;
            stickFigure.centerY = canvas.height - 100;

            const cx = stickFigure.centerX;
            const cy = stickFigure.centerY;
            const s = stickFigure.scale;

            ctx.save();

            // Draw background panel
            ctx.fillStyle = 'rgba(20, 20, 40, 0.7)';
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(cx - 100, cy - 95, 200, 190, 10);
            ctx.fill();
            ctx.stroke();

            // Draw stick figure body
            ctx.strokeStyle = 'rgba(200, 200, 220, 0.8)';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';

            // Head to center (neck/spine)
            const headPos = getStickNodePosition('head');
            const centerPos = getStickNodePosition('center');
            ctx.beginPath();
            ctx.moveTo(headPos.x, headPos.y + stickFigure.nodeRadius);
            ctx.lineTo(centerPos.x, centerPos.y);
            ctx.stroke();

            // Arms (center to hands)
            const leftHandPos = getStickNodePosition('leftHand');
            const rightHandPos = getStickNodePosition('rightHand');
            ctx.beginPath();
            ctx.moveTo(leftHandPos.x, leftHandPos.y);
            ctx.lineTo(cx, cy - 30 * s); // Shoulder area
            ctx.lineTo(rightHandPos.x, rightHandPos.y);
            ctx.stroke();

            // Legs (center to feet)
            const leftFootPos = getStickNodePosition('leftFoot');
            const rightFootPos = getStickNodePosition('rightFoot');
            ctx.beginPath();
            ctx.moveTo(leftFootPos.x, leftFootPos.y);
            ctx.lineTo(cx, cy + 20 * s); // Hip area
            ctx.lineTo(rightFootPos.x, rightFootPos.y);
            ctx.stroke();

            // Torso (shoulders to hips)
            ctx.beginPath();
            ctx.moveTo(cx, cy - 30 * s);
            ctx.lineTo(cx, cy + 20 * s);
            ctx.stroke();

            // Draw nodes on body parts
            const nodeNames = ['head', 'center', 'leftHand', 'rightHand', 'leftFoot', 'rightFoot'];
            nodeNames.forEach(nodeName => {
                const pos = getStickNodePosition(nodeName);
                const color = getNodeColor(nodeName);
                const spell = stickFigure.nodes[nodeName];
                const state = nodeStates[nodeName] || 'dormant';
                const activationProg = nodeActivationProgress[nodeName] || 0;

                if (state === 'dormant') {
                    // DORMANT: dim, outline only
                    ctx.strokeStyle = hexToRgba(color, 0.4);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, stickFigure.nodeRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Very faint fill
                    ctx.fillStyle = hexToRgba(color, 0.1);
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, stickFigure.nodeRadius, 0, Math.PI * 2);
                    ctx.fill();

                } else if (state === 'activating') {
                    // ACTIVATING: dim node with circular progress bar
                    // Dim fill
                    ctx.fillStyle = hexToRgba(color, 0.25);
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, stickFigure.nodeRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Dim outline
                    ctx.strokeStyle = hexToRgba(color, 0.5);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, stickFigure.nodeRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Progress bar (circular arc around node)
                    const progressRadius = stickFigure.nodeRadius + 5;
                    const startAngle = -Math.PI / 2; // Start at top
                    const endAngle = startAngle + (activationProg * Math.PI * 2);

                    // Background track
                    ctx.strokeStyle = hexToRgba(color, 0.2);
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, progressRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Progress fill
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, progressRadius, startAngle, endAngle);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    ctx.lineCap = 'butt';

                } else if (state === 'active') {
                    // ACTIVE: bright, glowing, fully powered
                    // Outer glow
                    const glowSize = stickFigure.nodeRadius + 10 + Math.sin(animationTime * 4) * 2;
                    const glowGradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, glowSize);
                    glowGradient.addColorStop(0, hexToRgba(color, 0.8));
                    glowGradient.addColorStop(0.4, hexToRgba(color, 0.4));
                    glowGradient.addColorStop(0.7, hexToRgba(color, 0.15));
                    glowGradient.addColorStop(1, hexToRgba(color, 0));
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, glowSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Bright filled node
                    ctx.fillStyle = color;
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, stickFigure.nodeRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Bright outline
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, stickFigure.nodeRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Inner bright core
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, stickFigure.nodeRadius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Label for spell type (only show on active nodes or always dim on others)
                if (spell !== 'dud') {
                    ctx.fillStyle = state === 'active' ? '#fff' : hexToRgba('#fff', 0.4);
                    ctx.font = state === 'active' ? 'bold 10px Georgia' : '9px Georgia';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const label = spell.charAt(0).toUpperCase();
                    ctx.fillText(label, pos.x, pos.y);
                }
            });

            // Draw awareness indicator (pulsing white ring around current position)
            const awPulse = Math.sin(animationTime * 6) * 0.3 + 0.7; // Pulsing opacity
            const awSize = stickFigure.nodeRadius + 6 + Math.sin(animationTime * 4) * 3; // Pulsing size

            // Outer glow
            const awGlow = ctx.createRadialGradient(
                stickAwarenessPos.x, stickAwarenessPos.y, awSize - 4,
                stickAwarenessPos.x, stickAwarenessPos.y, awSize + 12
            );
            awGlow.addColorStop(0, `rgba(255, 255, 255, ${awPulse * 0.5})`);
            awGlow.addColorStop(0.5, `rgba(200, 220, 255, ${awPulse * 0.3})`);
            awGlow.addColorStop(1, 'rgba(200, 220, 255, 0)');
            ctx.fillStyle = awGlow;
            ctx.beginPath();
            ctx.arc(stickAwarenessPos.x, stickAwarenessPos.y, awSize + 12, 0, Math.PI * 2);
            ctx.fill();

            // Bright ring
            ctx.strokeStyle = `rgba(255, 255, 255, ${awPulse})`;
            ctx.lineWidth = 3;
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(stickAwarenessPos.x, stickAwarenessPos.y, awSize, 0, Math.PI * 2);
            ctx.stroke();

            // Inner bright ring
            ctx.strokeStyle = `rgba(200, 230, 255, ${awPulse * 0.8})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(stickAwarenessPos.x, stickAwarenessPos.y, awSize - 4, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText('BODY NODES', cx, cy - 82);

            ctx.restore();
        }

        // Spell types
        const NEUTRAL = 'neutral';
        const SPIRAL = 'spiral';
        const PULSE = 'pulse';
        const ZAP = 'zap';

        // Colors
        const colors = {
            neutral: '#95a5a6',
            spiral: '#9b59b6',
            pulse: '#e74c3c',
            zap: '#f1c40f'
        };

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Determine winner: returns 1 if a wins, -1 if b wins, 0 if tie
        function getClashResult(a, b) {
            if (a === b) return 0;
            if ((a === SPIRAL && b === ZAP) ||
                (a === ZAP && b === PULSE) ||
                (a === PULSE && b === SPIRAL)) {
                return 1;
            }
            return -1;
        }

        // Enemy AI - sticky random
        function pickNewEnemyBeam() {
            const choices = [SPIRAL, PULSE, ZAP];
            let newBeam;
            do {
                newBeam = choices[Math.floor(Math.random() * choices.length)];
            } while (newBeam === enemyCurrentBeam && enemyCurrentBeam !== null);

            enemyCurrentBeam = newBeam;
            enemyClashesRemaining = 3 + Math.floor(Math.random() * 2);
        }

        function getEnemyChoice() {
            if (enemyCurrentBeam === null || enemyClashesRemaining <= 0) {
                pickNewEnemyBeam();
            }
            return enemyCurrentBeam;
        }

        function showClashResult(text, color) {
            clashResult.textContent = text;
            clashResult.style.color = color;
            clashResult.style.opacity = 1;
            setTimeout(() => {
                clashResult.style.opacity = 0;
            }, 1000);
        }

        function clash() {
            if (!gameActive) return;

            const player = playerChoice || getEnemyChoice();
            const enemy = getEnemyChoice();

            const result = getClashResult(player, enemy);

            let resultText = '';
            let resultColor = 'white';

            if (result === 1) {
                ballPosition = Math.min(100, ballPosition + 10);
                resultText = `${player.toUpperCase()} beats ${enemy.toUpperCase()}! +10%`;
                resultColor = '#2ecc71';
            } else if (result === -1) {
                ballPosition = Math.max(0, ballPosition - 10);
                resultText = `${enemy.toUpperCase()} beats ${player.toUpperCase()}! -10%`;
                resultColor = '#e74c3c';
            } else {
                resultText = `Both chose ${player.toUpperCase()}! TIE`;
                resultColor = '#f1c40f';
            }

            showClashResult(resultText, resultColor);

            const { meterY, clashX } = getBeamPositions();
            clashFlashIntensity = 1;
            lastClashResult = result;
            createClashParticles(clashX, meterY, resultColor);

            enemyClashesRemaining--;

            if (ballPosition <= 0) {
                endGame(false);
            } else if (ballPosition >= 100) {
                endGame(true);
            }
        }

        function endGame(playerWon) {
            gameActive = false;
            gameOverScreen.style.display = 'flex';

            if (playerWon) {
                gameOverScreen.className = 'win';
                gameOverText.textContent = 'Enemy vaporized!';
            } else {
                gameOverScreen.className = 'lose';
                gameOverText.textContent = 'You were vaporized!';
            }
        }

        function restartGame() {
            ballPosition = 50;
            playerChoice = NEUTRAL;
            gameActive = true;
            lastClashTime = performance.now();
            gameOverScreen.style.display = 'none';
            enemyCurrentBeam = null;
            enemyClashesRemaining = 0;
            pickNewEnemyBeam();
            particles = [];
            clashFlashIntensity = 0;
            initStickFigureNodes();
            initNodeStates();
            initStickAwareness();
            initBoostAndCooldowns();
            updateButtonStates();
        }

        function updateButtonStates() {
            neutralBtn.style.outline = playerChoice === NEUTRAL ? '4px solid white' : 'none';
            spiralBtn.style.outline = playerChoice === SPIRAL ? '4px solid white' : 'none';
            pulseBtn.style.outline = playerChoice === PULSE ? '4px solid white' : 'none';
            zapBtn.style.outline = playerChoice === ZAP ? '4px solid white' : 'none';
        }

        function selectSpell(spell) {
            if (!gameActive) return;
            playerChoice = spell;
            updateButtonStates();
        }

        function activateBoost(spell) {
            if (!gameActive) return;

            const now = performance.now();

            // Special rule: Switching TO Neutral has NO cooldown (can always bail to safety)
            if (spell === NEUTRAL) {
                playerBeamType = NEUTRAL;
                playerChoice = NEUTRAL;
                // Clear all cooldowns when going to neutral
                cooldowns.neutral = 0;
                cooldowns.spiral = 0;
                cooldowns.pulse = 0;
                cooldowns.zap = 0;
                updateButtonStates();
                return;
            }

            // For attack types (Spiral/Pulse/Zap):
            // Check if ANY attack cooldown is active
            const attackCooldownActive = cooldowns.spiral > now || cooldowns.pulse > now || cooldowns.zap > now;
            if (attackCooldownActive) return;

            // Commit to this attack beam type
            playerBeamType = spell;

            // Put ALL attack buttons on cooldown (committed for 5 seconds)
            // Neutral never has cooldown
            cooldowns.neutral = 0;
            cooldowns.spiral = now + cooldownDuration;
            cooldowns.pulse = now + cooldownDuration;
            cooldowns.zap = now + cooldownDuration;

            // Also select this spell for visual
            playerChoice = spell;
            updateButtonStates();
        }

        function getEffectiveMana() {
            let effective = playerActiveMana;

            // Add counter modifier based on beam matchup
            const modifier = getCounterModifier();
            effective += modifier;

            // Floor at 0 (can't have negative effective mana)
            return Math.max(0, effective);
        }

        function updateCooldownDisplay() {
            const now = performance.now();
            const maxRemaining = Math.max(
                cooldowns.spiral - now,
                cooldowns.pulse - now,
                cooldowns.zap - now
            );
            const attackOnCooldown = maxRemaining > 0;

            // Handle attack buttons (Spiral, Pulse, Zap)
            [SPIRAL, PULSE, ZAP].forEach(spell => {
                const btn = spell === SPIRAL ? spiralBtn : spell === PULSE ? pulseBtn : zapBtn;
                const isActive = playerBeamType === spell;

                if (attackOnCooldown) {
                    btn.disabled = true;
                    if (isActive) {
                        // This is the active beam
                        btn.textContent = `${spell.toUpperCase()} (${(maxRemaining / 1000).toFixed(1)}s)`;
                        btn.style.opacity = '1';
                        btn.style.outline = '3px solid white';
                    } else {
                        btn.textContent = spell.toUpperCase();
                        btn.style.opacity = '0.4';
                        btn.style.outline = 'none';
                    }
                } else {
                    btn.disabled = false;
                    btn.textContent = spell.toUpperCase();
                    btn.style.opacity = '1';
                    btn.style.outline = isActive ? '3px solid white' : 'none';
                }
            });

            // Neutral button is ALWAYS available (no cooldown to switch to it)
            const neutralActive = playerBeamType === NEUTRAL;
            neutralBtn.disabled = false;
            neutralBtn.textContent = 'NEUTRAL';
            neutralBtn.style.opacity = '1';
            neutralBtn.style.outline = neutralActive ? '3px solid white' : 'none';
        }

        function initBoostAndCooldowns() {
            // Start in NEUTRAL - safe, no modifier
            playerBeamType = NEUTRAL;
            playerChoice = NEUTRAL;
            cooldowns = { neutral: 0, spiral: 0, pulse: 0, zap: 0 };
            // Initialize enemy with a random beam
            switchEnemyBeam();
            updateCooldownDisplay();
        }

        function switchEnemyBeam() {
            // Enemy can use all beam types including neutral
            const beams = [NEUTRAL, SPIRAL, PULSE, ZAP];
            // Pick a different beam than current
            let newBeam;
            do {
                newBeam = beams[Math.floor(Math.random() * beams.length)];
            } while (newBeam === enemyBeamType && enemyBeamType !== null);

            enemyBeamType = newBeam;
            enemyBeamSwitchTime = performance.now() + 4000 + Math.random() * 4000; // 4-8 seconds
        }

        function updateEnemyBeam(timestamp) {
            if (timestamp >= enemyBeamSwitchTime) {
                switchEnemyBeam();
            }
        }

        neutralBtn.addEventListener('click', () => activateBoost(NEUTRAL));
        spiralBtn.addEventListener('click', () => activateBoost(SPIRAL));
        pulseBtn.addEventListener('click', () => activateBoost(PULSE));
        zapBtn.addEventListener('click', () => activateBoost(ZAP));
        restartBtn.addEventListener('click', restartGame);

        // Drawing functions
        function drawBackground() {
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, '#1a1a3a');
            gradient.addColorStop(1, '#0a0a1a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawWizard(x, y, isPlayer, color) {
            ctx.save();
            ctx.translate(x, y);

            ctx.fillStyle = isPlayer ? '#3498db' : '#9b59b6';
            ctx.beginPath();
            ctx.moveTo(0, -30);
            ctx.lineTo(-30, 50);
            ctx.lineTo(30, 50);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(0, -80);
            ctx.lineTo(-25, -30);
            ctx.lineTo(25, -30);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#fad7a0';
            ctx.beginPath();
            ctx.arc(0, -15, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(isPlayer ? 5 : -5, -18, 3, 0, Math.PI * 2);
            ctx.arc(isPlayer ? -5 : 5, -18, 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(isPlayer ? 35 : -35, -20);
            ctx.lineTo(isPlayer ? 50 : -50, 40);
            ctx.stroke();

            ctx.fillStyle = color || '#fff';
            ctx.shadowColor = color || '#fff';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(isPlayer ? 35 : -35, -25, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.restore();
        }

        function drawBeamMeter() {
            const { meterY, clashX } = getBeamPositions();

            const glowSize = 30 + Math.sin(animationTime * 5) * 5;

            const ballGradient = ctx.createRadialGradient(clashX, meterY, 0, clashX, meterY, glowSize);
            ballGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            ballGradient.addColorStop(0.3, 'rgba(100, 200, 255, 0.8)');
            ballGradient.addColorStop(0.6, 'rgba(100, 150, 255, 0.4)');
            ballGradient.addColorStop(1, 'rgba(100, 100, 255, 0)');

            ctx.fillStyle = ballGradient;
            ctx.beginPath();
            ctx.arc(clashX, meterY, glowSize, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(clashX, meterY, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function getBeamPositions() {
            const meterY = canvas.height / 2;
            const playerStartX = 135;
            const enemyStartX = canvas.width - 135;
            const beamLength = enemyStartX - playerStartX;
            const clashX = playerStartX + (ballPosition / 100) * beamLength;
            return { meterY, clashX, playerStartX, enemyStartX, beamLength };
        }

        function getClashProgress() {
            const now = performance.now();
            const elapsed = now - lastClashTime;
            return Math.min(1, elapsed / clashInterval);
        }

        function drawBaseEnergyBeam() {
            const { meterY, clashX, playerStartX, enemyStartX } = getBeamPositions();

            ctx.save();

            // Calculate beam thickness based on active mana
            const playerThickness = getBeamThickness(playerActiveMana);
            const enemyThickness = getBeamThickness(enemyActiveMana);

            const playerColor = colors[playerChoice];
            const playerGradient = ctx.createLinearGradient(playerStartX, 0, clashX, 0);
            const flowOffset = (animationTime * 0.5) % 1;

            for (let i = 0; i < 5; i++) {
                const pos = ((i / 5) + flowOffset) % 1;
                const alpha = 0.15 + Math.sin(pos * Math.PI) * 0.1;
                playerGradient.addColorStop(Math.min(0.99, Math.max(0.01, pos)), hexToRgba(playerColor, alpha));
            }

            ctx.strokeStyle = playerGradient;
            ctx.lineWidth = playerThickness;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(playerStartX, meterY);
            ctx.lineTo(clashX, meterY);
            ctx.stroke();

            const playerCoreGradient = ctx.createLinearGradient(playerStartX, 0, clashX, 0);
            playerCoreGradient.addColorStop(0, hexToRgba(playerColor, 0.4));
            playerCoreGradient.addColorStop(1, hexToRgba(playerColor, 0.2));
            ctx.strokeStyle = playerCoreGradient;
            ctx.lineWidth = playerThickness * 0.35;
            ctx.beginPath();
            ctx.moveTo(playerStartX, meterY);
            ctx.lineTo(clashX, meterY);
            ctx.stroke();

            const playerBeamLength = clashX - playerStartX;
            const playerParticleCount = Math.floor(4 + (playerActiveMana / 6) * 8); // More particles with more mana
            for (let i = 0; i < playerParticleCount; i++) {
                const particleT = ((i / playerParticleCount) + animationTime * 0.8) % 1;
                const px = playerStartX + particleT * playerBeamLength;
                const py = meterY + Math.sin(animationTime * 10 + i * 2) * (playerThickness * 0.25);
                const particleSize = (2 + Math.sin(animationTime * 8 + i) * 1) * (playerThickness / 12);
                const particleAlpha = 0.3 + Math.sin(particleT * Math.PI) * 0.4;

                ctx.fillStyle = hexToRgba(playerColor, particleAlpha);
                ctx.beginPath();
                ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                ctx.fill();
            }

            const enemyColor = colors[enemyBeamType] || '#9b59b6';
            const enemyGradient = ctx.createLinearGradient(enemyStartX, 0, clashX, 0);
            const enemyFlowOffset = (animationTime * 0.5) % 1;

            for (let i = 0; i < 5; i++) {
                const pos = ((i / 5) + enemyFlowOffset) % 1;
                const alpha = 0.15 + Math.sin(pos * Math.PI) * 0.1;
                enemyGradient.addColorStop(Math.min(0.99, Math.max(0.01, 1 - pos)), hexToRgba(enemyColor, alpha));
            }

            ctx.strokeStyle = enemyGradient;
            ctx.lineWidth = enemyThickness;
            ctx.beginPath();
            ctx.moveTo(enemyStartX, meterY);
            ctx.lineTo(clashX, meterY);
            ctx.stroke();

            const enemyCoreGradient = ctx.createLinearGradient(enemyStartX, 0, clashX, 0);
            enemyCoreGradient.addColorStop(0, hexToRgba(enemyColor, 0.4));
            enemyCoreGradient.addColorStop(1, hexToRgba(enemyColor, 0.2));
            ctx.strokeStyle = enemyCoreGradient;
            ctx.lineWidth = enemyThickness * 0.35;
            ctx.beginPath();
            ctx.moveTo(enemyStartX, meterY);
            ctx.lineTo(clashX, meterY);
            ctx.stroke();

            const enemyBeamLength = enemyStartX - clashX;
            const enemyParticleCount = Math.floor(4 + (enemyActiveMana / 6) * 8); // More particles with more mana
            for (let i = 0; i < enemyParticleCount; i++) {
                const particleT = ((i / enemyParticleCount) + animationTime * 0.8) % 1;
                const px = enemyStartX - particleT * enemyBeamLength;
                const py = meterY + Math.sin(animationTime * 10 + i * 2 + Math.PI) * (enemyThickness * 0.25);
                const particleSize = (2 + Math.sin(animationTime * 8 + i + Math.PI) * 1) * (enemyThickness / 12);
                const particleAlpha = 0.3 + Math.sin(particleT * Math.PI) * 0.4;

                ctx.fillStyle = hexToRgba(enemyColor, particleAlpha);
                ctx.beginPath();
                ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                ctx.fill();
            }

            const pulseSize = 15 + Math.sin(animationTime * 6) * 5;
            const clashGlow = ctx.createRadialGradient(clashX, meterY, 0, clashX, meterY, pulseSize);
            clashGlow.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            clashGlow.addColorStop(0.5, 'rgba(255, 255, 255, 0.15)');
            clashGlow.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = clashGlow;
            ctx.beginPath();
            ctx.arc(clashX, meterY, pulseSize, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // SPIRAL BEAM
        function drawSpiralBeam(startX, endX, y, color, isPlayer, thickness = 12) {
            const progress = getClashProgress();
            const length = Math.abs(endX - startX);
            const thicknessScale = thickness / 12; // Scale factor relative to default

            ctx.save();

            const projectileX = isPlayer ?
                startX + progress * length :
                startX - progress * length;

            const traveledLength = Math.abs(projectileX - startX);
            const segments = Math.max(20, Math.floor(traveledLength / 5));
            const amplitude = 15 * thicknessScale;
            const frequency = 0.08;
            const rotationSpeed = 10;

            for (let spiral = 0; spiral < 2; spiral++) {
                const phaseOffset = spiral * Math.PI;
                ctx.beginPath();

                const spiralGradient = isPlayer ?
                    ctx.createLinearGradient(startX, 0, projectileX, 0) :
                    ctx.createLinearGradient(startX, 0, projectileX, 0);
                spiralGradient.addColorStop(0, hexToRgba(color, 0.3));
                spiralGradient.addColorStop(0.7, hexToRgba(color, 0.6));
                spiralGradient.addColorStop(1, hexToRgba(color, 0.8));

                ctx.strokeStyle = spiralGradient;
                ctx.lineWidth = (3 - spiral) * thicknessScale;

                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const x = isPlayer ?
                        startX + t * traveledLength :
                        startX - t * traveledLength;

                    const waveOffset = Math.sin(t * traveledLength * frequency + animationTime * rotationSpeed + phaseOffset) * amplitude;

                    if (i === 0) {
                        ctx.moveTo(x, y + waveOffset);
                    } else {
                        ctx.lineTo(x, y + waveOffset);
                    }
                }
                ctx.stroke();
            }

            const particleCount = Math.floor(4 + thicknessScale * 4);
            for (let i = 0; i < particleCount; i++) {
                const t = (i / particleCount + animationTime * 0.5) % 1;
                const px = isPlayer ?
                    startX + t * traveledLength :
                    startX - t * traveledLength;
                const py = y + Math.sin(t * traveledLength * frequency + animationTime * rotationSpeed) * amplitude;

                ctx.fillStyle = hexToRgba(color, 0.6);
                ctx.beginPath();
                ctx.arc(px, py, 3 * thicknessScale, 0, Math.PI * 2);
                ctx.fill();
            }

            const projectileSize = 20 * thicknessScale;
            const spiralArms = 3;
            const projRotation = animationTime * 15;

            const glowGradient = ctx.createRadialGradient(projectileX, y, 0, projectileX, y, projectileSize * 2);
            glowGradient.addColorStop(0, hexToRgba(color, 0.7));
            glowGradient.addColorStop(0.5, hexToRgba(color, 0.3));
            glowGradient.addColorStop(1, hexToRgba(color, 0));
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(projectileX, y, projectileSize * 2, 0, Math.PI * 2);
            ctx.fill();

            for (let arm = 0; arm < spiralArms; arm++) {
                const armAngle = (Math.PI * 2 * arm) / spiralArms + projRotation;
                ctx.strokeStyle = hexToRgba(color, 0.9);
                ctx.lineWidth = 3 * thicknessScale;
                ctx.beginPath();

                for (let i = 0; i <= 12; i++) {
                    const t = i / 12;
                    const radius = t * projectileSize;
                    const angle = armAngle + t * Math.PI * 2;
                    const px = projectileX + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;

                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();
            }

            ctx.fillStyle = '#fff';
            ctx.shadowColor = color;
            ctx.shadowBlur = 15 * thicknessScale;
            ctx.beginPath();
            ctx.arc(projectileX, y, 7 * thicknessScale, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // ZAP BEAM
        function drawZapBeam(startX, endX, y, color, isPlayer, thickness = 12) {
            const progress = getClashProgress();
            const length = Math.abs(endX - startX);
            const thicknessScale = thickness / 12; // Scale factor relative to default

            ctx.save();

            const projectileX = isPlayer ?
                startX + progress * length :
                startX - progress * length;

            const traveledLength = Math.abs(projectileX - startX);
            const segments = Math.max(15, Math.floor(traveledLength / 8));

            ctx.shadowColor = color;
            ctx.shadowBlur = 10 * thicknessScale;

            const boltGradient = isPlayer ?
                ctx.createLinearGradient(startX, 0, projectileX, 0) :
                ctx.createLinearGradient(startX, 0, projectileX, 0);
            boltGradient.addColorStop(0, hexToRgba(color, 0.4));
            boltGradient.addColorStop(0.5, hexToRgba(color, 0.7));
            boltGradient.addColorStop(1, hexToRgba(color, 0.9));

            ctx.beginPath();
            ctx.strokeStyle = boltGradient;
            ctx.lineWidth = 3 * thicknessScale;

            ctx.moveTo(startX, y);

            for (let i = 1; i <= segments; i++) {
                const t = i / segments;
                const x = isPlayer ?
                    startX + t * traveledLength :
                    startX - t * traveledLength;
                const jitter = (Math.sin(i * 2.7 + animationTime * 35) * 18 +
                              Math.sin(i * 5.3 + animationTime * 55) * 10) * thicknessScale;
                ctx.lineTo(x, y + jitter);
            }
            ctx.stroke();

            ctx.beginPath();
            ctx.strokeStyle = hexToRgba(color, 0.5);
            ctx.lineWidth = 2 * thicknessScale;
            ctx.moveTo(startX, y);

            for (let i = 1; i <= segments; i++) {
                const t = i / segments;
                const x = isPlayer ?
                    startX + t * traveledLength :
                    startX - t * traveledLength;
                const jitter = (Math.cos(i * 3.1 + animationTime * 45) * 22 +
                              Math.sin(i * 6.7 + animationTime * 65) * 12) * thicknessScale;
                ctx.lineTo(x, y + jitter);
            }
            ctx.stroke();

            const sparkCount = Math.floor(6 + thicknessScale * 6);
            for (let i = 0; i < sparkCount; i++) {
                const t = (i / sparkCount + animationTime * 0.3) % 1;
                const sparkX = isPlayer ?
                    startX + t * traveledLength :
                    startX - t * traveledLength;
                const sparkY = y + Math.sin(t * 50 + animationTime * 40 + i * 7) * 20 * thicknessScale;
                const sparkSize = (2 + Math.sin(animationTime * 30 + i * 5) * 1.5) * thicknessScale;

                ctx.fillStyle = hexToRgba(color, 0.7);
                ctx.beginPath();
                ctx.arc(sparkX, sparkY, Math.max(1, sparkSize), 0, Math.PI * 2);
                ctx.fill();
            }

            const projectileSize = 18 * thicknessScale;

            const glowGradient = ctx.createRadialGradient(projectileX, y, 0, projectileX, y, projectileSize * 2.5);
            glowGradient.addColorStop(0, hexToRgba(color, 0.8));
            glowGradient.addColorStop(0.4, hexToRgba(color, 0.4));
            glowGradient.addColorStop(1, hexToRgba(color, 0));
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(projectileX, y, projectileSize * 2.5, 0, Math.PI * 2);
            ctx.fill();

            const boltCount = 8;
            for (let i = 0; i < boltCount; i++) {
                const baseAngle = (Math.PI * 2 * i) / boltCount;
                const angle = baseAngle + Math.sin(animationTime * 25 + i * 4) * 0.4;
                const boltLength = (25 + Math.sin(animationTime * 35 + i * 3) * 12) * thicknessScale;

                ctx.strokeStyle = hexToRgba(color, 0.85);
                ctx.lineWidth = 2 * thicknessScale;
                ctx.beginPath();
                ctx.moveTo(projectileX, y);

                let bx = projectileX;
                let by = y;
                for (let j = 1; j <= 4; j++) {
                    const dist = (boltLength / 4) * j;
                    const jitter = Math.sin(animationTime * 50 + i * 10 + j * 5) * 6 * thicknessScale;
                    bx = projectileX + Math.cos(angle) * dist + Math.cos(angle + Math.PI/2) * jitter;
                    by = y + Math.sin(angle) * dist + Math.sin(angle + Math.PI/2) * jitter;
                    ctx.lineTo(bx, by);
                }
                ctx.stroke();
            }

            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 25 * thicknessScale;
            ctx.beginPath();
            ctx.arc(projectileX, y, 9 * thicknessScale, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ffffaa';
            ctx.beginPath();
            ctx.arc(projectileX, y, 5 * thicknessScale, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // PULSE BEAM
        function drawPulseBeam(startX, endX, y, color, isPlayer, thickness = 12) {
            const progress = getClashProgress();
            const length = endX - startX;
            const thicknessScale = thickness / 12; // Scale factor relative to default

            ctx.save();

            const orbX = isPlayer ?
                startX + progress * length :
                startX - progress * Math.abs(length);

            const trailLength = 50 * thicknessScale;
            const trailStartX = isPlayer ?
                Math.max(startX, orbX - trailLength) :
                Math.min(startX, orbX + trailLength);

            const orbTrailGradient = ctx.createLinearGradient(trailStartX, 0, orbX, 0);
            orbTrailGradient.addColorStop(0, hexToRgba(color, 0));
            orbTrailGradient.addColorStop(1, hexToRgba(color, 0.6));
            ctx.strokeStyle = orbTrailGradient;
            ctx.lineWidth = 8 * thicknessScale;
            ctx.beginPath();
            ctx.moveTo(trailStartX, y);
            ctx.lineTo(orbX, y);
            ctx.stroke();

            const orbSize = (15 + Math.sin(animationTime * 10) * 3) * thicknessScale;

            const glowGradient = ctx.createRadialGradient(orbX, y, 0, orbX, y, orbSize * 2);
            glowGradient.addColorStop(0, hexToRgba(color, 0.8));
            glowGradient.addColorStop(0.5, hexToRgba(color, 0.3));
            glowGradient.addColorStop(1, hexToRgba(color, 0));
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(orbX, y, orbSize * 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.shadowColor = color;
            ctx.shadowBlur = 20 * thicknessScale;
            ctx.beginPath();
            ctx.arc(orbX, y, orbSize * 0.6, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // NEUTRAL BEAM - simple, no special effects
        function drawNeutralBeam(startX, endX, y, color, isPlayer, thickness = 12) {
            const progress = getClashProgress();
            const length = Math.abs(endX - startX);
            const thicknessScale = thickness / 12;

            ctx.save();

            const projectileX = isPlayer ?
                startX + progress * length :
                startX - progress * length;

            const traveledLength = Math.abs(projectileX - startX);

            // Simple straight beam - no fancy effects
            const beamGradient = isPlayer ?
                ctx.createLinearGradient(startX, 0, projectileX, 0) :
                ctx.createLinearGradient(startX, 0, projectileX, 0);
            beamGradient.addColorStop(0, hexToRgba(color, 0.3));
            beamGradient.addColorStop(0.5, hexToRgba(color, 0.5));
            beamGradient.addColorStop(1, hexToRgba(color, 0.7));

            ctx.strokeStyle = beamGradient;
            ctx.lineWidth = 4 * thicknessScale;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(startX, y);
            ctx.lineTo(projectileX, y);
            ctx.stroke();

            // Simple core line
            ctx.strokeStyle = hexToRgba('#ffffff', 0.4);
            ctx.lineWidth = 2 * thicknessScale;
            ctx.beginPath();
            ctx.moveTo(startX, y);
            ctx.lineTo(projectileX, y);
            ctx.stroke();

            // Simple projectile - just a soft glow
            const projectileSize = 12 * thicknessScale;

            const glowGradient = ctx.createRadialGradient(projectileX, y, 0, projectileX, y, projectileSize * 1.5);
            glowGradient.addColorStop(0, hexToRgba(color, 0.6));
            glowGradient.addColorStop(0.5, hexToRgba(color, 0.3));
            glowGradient.addColorStop(1, hexToRgba(color, 0));
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(projectileX, y, projectileSize * 1.5, 0, Math.PI * 2);
            ctx.fill();

            // White center
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(projectileX, y, projectileSize * 0.4, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawBeamByType(beamType, startX, endX, y, color, isPlayer, thickness = 12) {
            switch (beamType) {
                case NEUTRAL:
                    drawNeutralBeam(startX, endX, y, color, isPlayer, thickness);
                    break;
                case SPIRAL:
                    drawSpiralBeam(startX, endX, y, color, isPlayer, thickness);
                    break;
                case ZAP:
                    drawZapBeam(startX, endX, y, color, isPlayer, thickness);
                    break;
                case PULSE:
                    drawPulseBeam(startX, endX, y, color, isPlayer, thickness);
                    break;
                default:
                    drawNeutralBeam(startX, endX, y, color, isPlayer, thickness);
            }
        }

        function drawBeams() {
            const { meterY, clashX, playerStartX, enemyStartX } = getBeamPositions();

            // Calculate beam thickness based on active mana
            const playerThickness = getBeamThickness(playerActiveMana);
            const enemyThickness = getBeamThickness(enemyActiveMana);

            const playerColor = colors[playerChoice];
            drawBeamByType(playerChoice, playerStartX, clashX, meterY, playerColor, true, playerThickness);

            const enemyColor = colors[enemyBeamType] || '#9b59b6';
            if (enemyBeamType) {
                drawBeamByType(enemyBeamType, enemyStartX, clashX, meterY, enemyColor, false, enemyThickness);
            }
        }

        function createClashParticles(x, y, resultColor) {
            const particleCount = 30;
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
                const speed = 3 + Math.random() * 5;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 3 + Math.random() * 4,
                    color: resultColor
                });
            }
        }

        function updateAndDrawParticles() {
            ctx.save();
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1;
                p.life -= p.decay;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }

                ctx.beginPath();
                ctx.fillStyle = hexToRgba(p.color, p.life);
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 10;
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function drawClashFlash() {
            if (clashFlashIntensity > 0) {
                const { meterY, clashX } = getBeamPositions();

                ctx.save();

                let flashColor = '#ffffff';
                if (lastClashResult === 1) flashColor = '#2ecc71';
                else if (lastClashResult === -1) flashColor = '#e74c3c';
                else flashColor = '#f1c40f';

                const ringSize = 80 * (1 - clashFlashIntensity) + 20;
                const ringOpacity = clashFlashIntensity * 0.6;
                ctx.strokeStyle = hexToRgba(flashColor, ringOpacity);
                ctx.lineWidth = 4 * clashFlashIntensity;
                ctx.beginPath();
                ctx.arc(clashX, meterY, ringSize, 0, Math.PI * 2);
                ctx.stroke();

                const ring2Size = 60 * (1 - clashFlashIntensity) + 10;
                ctx.strokeStyle = hexToRgba(flashColor, ringOpacity * 0.7);
                ctx.lineWidth = 3 * clashFlashIntensity;
                ctx.beginPath();
                ctx.arc(clashX, meterY, ring2Size, 0, Math.PI * 2);
                ctx.stroke();

                const coreSize = 40 * clashFlashIntensity;
                const coreGradient = ctx.createRadialGradient(clashX, meterY, 0, clashX, meterY, coreSize);
                coreGradient.addColorStop(0, hexToRgba('#ffffff', clashFlashIntensity * 0.9));
                coreGradient.addColorStop(0.3, hexToRgba(flashColor, clashFlashIntensity * 0.7));
                coreGradient.addColorStop(0.7, hexToRgba(flashColor, clashFlashIntensity * 0.3));
                coreGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(clashX, meterY, coreSize, 0, Math.PI * 2);
                ctx.fill();

                const spikeCount = 8;
                for (let i = 0; i < spikeCount; i++) {
                    const angle = (Math.PI * 2 * i) / spikeCount;
                    const spikeLength = 50 * clashFlashIntensity;
                    const startDist = 15;

                    ctx.strokeStyle = hexToRgba(flashColor, clashFlashIntensity * 0.8);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(
                        clashX + Math.cos(angle) * startDist,
                        meterY + Math.sin(angle) * startDist
                    );
                    ctx.lineTo(
                        clashX + Math.cos(angle) * (startDist + spikeLength),
                        meterY + Math.sin(angle) * (startDist + spikeLength)
                    );
                    ctx.stroke();
                }

                clashFlashIntensity -= 0.04;
                if (clashFlashIntensity < 0) clashFlashIntensity = 0;

                ctx.restore();
            }
        }

        function drawTimer() {
            if (!gameActive) return;

            const manaDiff = getEffectiveMana() - enemyActiveMana;
            const counterMod = getCounterModifier();

            ctx.font = '20px Georgia';
            ctx.textAlign = 'center';

            // Show push status
            let statusText = '';
            let statusColor = '#f1c40f';
            if (manaDiff > 0) {
                statusText = `Pushing! (+${manaDiff} advantage)`;
                statusColor = '#2ecc71';
            } else if (manaDiff < 0) {
                statusText = `Being pushed! (${manaDiff} deficit)`;
                statusColor = '#e74c3c';
            } else {
                statusText = 'Deadlock';
                statusColor = '#f1c40f';
            }

            ctx.fillStyle = statusColor;
            ctx.shadowColor = statusColor;
            ctx.shadowBlur = 10;
            ctx.fillText(statusText, canvas.width / 2, 80);
            ctx.shadowBlur = 0;

            // Show beam matchup in center
            ctx.font = '16px Georgia';
            if (playerBeamType && enemyBeamType) {
                const playerColor = colors[playerBeamType];
                const enemyColor = colors[enemyBeamType];

                // Player beam
                ctx.textAlign = 'right';
                ctx.fillStyle = playerColor;
                ctx.fillText(playerBeamType.toUpperCase(), canvas.width / 2 - 30, 60);

                // VS
                ctx.textAlign = 'center';
                ctx.fillStyle = '#fff';
                ctx.fillText('vs', canvas.width / 2, 60);

                // Enemy beam
                ctx.textAlign = 'left';
                ctx.fillStyle = enemyColor;
                ctx.fillText(enemyBeamType.toUpperCase(), canvas.width / 2 + 30, 60);
            } else if (!playerBeamType) {
                ctx.fillStyle = '#888';
                ctx.fillText('Select a beam type to engage!', canvas.width / 2, 60);
            }
        }

        function drawTitle() {
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 28px Georgia';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10;
            ctx.fillText('WIZARD BEAMS', canvas.width / 2, 40);
            ctx.shadowBlur = 0;
        }

        function drawActiveMana() {
            const effectiveMana = getEffectiveMana();
            const counterMod = getCounterModifier();
            const isCountering = counterMod > 0;
            const isCountered = counterMod < 0;

            // Player active mana (left side)
            ctx.textAlign = 'left';
            ctx.font = 'bold 16px Georgia';

            // Background box for player
            let boxColor = 'rgba(20, 20, 40, 0.8)';
            let borderColor = 'rgba(100, 150, 255, 0.5)';
            if (isCountering) {
                boxColor = 'rgba(30, 60, 30, 0.9)';
                borderColor = 'rgba(100, 255, 100, 0.8)';
            } else if (isCountered) {
                boxColor = 'rgba(60, 30, 30, 0.9)';
                borderColor = 'rgba(255, 100, 100, 0.8)';
            }
            ctx.fillStyle = boxColor;
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = playerBeamType ? 3 : 2;
            ctx.beginPath();
            ctx.roundRect(20, 100, 200, 65, 8);
            ctx.fill();
            ctx.stroke();

            // Player beam type indicator
            if (playerBeamType) {
                const beamColor = colors[playerBeamType];
                ctx.fillStyle = beamColor;
                ctx.shadowColor = beamColor;
                ctx.shadowBlur = 10;
                ctx.fillText(`Beam: ${playerBeamType.toUpperCase()}`, 32, 118);
                ctx.shadowBlur = 0;
            } else {
                ctx.fillStyle = '#888';
                ctx.fillText('Beam: NONE', 32, 118);
            }

            // Player mana with modifier
            ctx.font = 'bold 14px Georgia';
            let manaText = `Mana: ${playerActiveMana}`;
            let manaColor = '#3498db';
            if (counterMod !== 0) {
                const sign = counterMod > 0 ? '+' : '';
                manaText += ` ${sign}${counterMod} = ${effectiveMana}`;
                manaColor = isCountering ? '#2ecc71' : '#e74c3c';
            }
            ctx.fillStyle = manaColor;
            ctx.shadowColor = manaColor;
            ctx.shadowBlur = 8;
            ctx.fillText(manaText, 32, 138);
            ctx.shadowBlur = 0;

            // Counter status
            ctx.font = '12px Georgia';
            if (isCountering) {
                ctx.fillStyle = '#2ecc71';
                ctx.fillText('COUNTERING! (+3)', 32, 155);
            } else if (isCountered) {
                ctx.fillStyle = '#e74c3c';
                ctx.fillText('COUNTERED! (-3)', 32, 155);
            } else if (playerBeamType && enemyBeamType) {
                ctx.fillStyle = '#f1c40f';
                ctx.fillText('NEUTRAL', 32, 155);
            }

            // Enemy active mana (right side)
            ctx.textAlign = 'right';
            ctx.font = 'bold 16px Georgia';

            // Background box for enemy
            ctx.fillStyle = 'rgba(20, 20, 40, 0.8)';
            ctx.strokeStyle = enemyBeamType ? colors[enemyBeamType] : 'rgba(155, 89, 182, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(canvas.width - 220, 100, 200, 65, 8);
            ctx.fill();
            ctx.stroke();

            // Enemy beam type indicator
            if (enemyBeamType) {
                const beamColor = colors[enemyBeamType];
                ctx.fillStyle = beamColor;
                ctx.shadowColor = beamColor;
                ctx.shadowBlur = 10;
                ctx.fillText(`Beam: ${enemyBeamType.toUpperCase()}`, canvas.width - 32, 118);
                ctx.shadowBlur = 0;
            }

            // Enemy mana
            ctx.font = 'bold 14px Georgia';
            ctx.fillStyle = '#9b59b6';
            ctx.shadowColor = '#9b59b6';
            ctx.shadowBlur = 8;
            ctx.fillText(`Mana: ${enemyActiveMana}`, canvas.width - 32, 138);
            ctx.shadowBlur = 0;

            // Show what beats enemy's beam
            ctx.font = '11px Georgia';
            ctx.fillStyle = '#888';
            if (enemyBeamType) {
                let counter = '';
                if (enemyBeamType === NEUTRAL) counter = 'N/A (Neutral)';
                else if (enemyBeamType === SPIRAL) counter = 'PULSE';
                else if (enemyBeamType === PULSE) counter = 'ZAP';
                else if (enemyBeamType === ZAP) counter = 'SPIRAL';
                ctx.fillText(`Counter with: ${counter}`, canvas.width - 32, 155);
            }

            // DEBUG: Show beam sync status
            ctx.textAlign = 'center';
            ctx.font = '10px monospace';
            ctx.fillStyle = '#666';
            ctx.fillText('DEBUG: Beam Sync Check', canvas.width / 2, canvas.height - 20);
            const visualBeam = enemyBeamType ? enemyBeamType.toUpperCase() : 'NONE';
            const calcBeam = enemyBeamType ? enemyBeamType.toUpperCase() : 'NONE';
            const syncStatus = visualBeam === calcBeam ? ' SYNCED' : ' MISMATCH';
            const syncColor = visualBeam === calcBeam ? '#2ecc71' : '#e74c3c';
            ctx.fillStyle = syncColor;
            ctx.fillText(`Visual: ${visualBeam} | Calc: ${calcBeam} | ${syncStatus}`, canvas.width / 2, canvas.height - 6);
        }

        canvas.addEventListener('click', (e) => {
            if (!gameActive) return;

            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Check for stick figure node clicks
            const clickedStickNode = getClickedStickNode(clickX, clickY);
            if (clickedStickNode) {
                moveStickAwarenessTo(clickedStickNode);
            }
        });

        function gameLoop(timestamp) {
            animationTime = timestamp / 1000;

            updateStickAwareness(timestamp);
            updateNodeActivation(timestamp);
            updateCooldownDisplay();
            updateEnemyBeam(timestamp);

            if (gameActive) {
                // Continuous tug-of-war based on active mana difference
                const manaDiff = getEffectiveMana() - enemyActiveMana;
                // Move 1% per second per mana difference
                const pushRate = 1.0; // percent per second per mana diff
                const deltaTime = 1 / 60; // approximate frame time
                const pushAmount = manaDiff * pushRate * deltaTime;

                ballPosition = Math.max(0, Math.min(100, ballPosition + pushAmount));

                // Check win/lose conditions
                if (ballPosition <= 0) {
                    endGame(false);
                } else if (ballPosition >= 100) {
                    endGame(true);
                }
            }

            drawBackground();
            drawBaseEnergyBeam();
            drawBeams();
            drawBeamMeter();
            drawStickFigure();
            drawWizard(100, canvas.height / 2, true, colors[playerChoice]);
            drawWizard(canvas.width - 100, canvas.height / 2, false, colors[enemyBeamType] || '#9b59b6');
            updateAndDrawParticles();
            drawClashFlash();
            drawTimer();
            drawTitle();
            drawActiveMana();

            requestAnimationFrame(gameLoop);
        }

        // Start game
        lastClashTime = performance.now();
        updateButtonStates();
        pickNewEnemyBeam();
        initStickFigureNodes();
        initNodeStates();
        initStickAwareness();
        initBoostAndCooldowns();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
