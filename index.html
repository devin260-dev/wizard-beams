<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wizard Beams</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a1a;
            font-family: 'Georgia', serif;
        }

        #gameCanvas {
            display: block;
        }

        #controls {
            position: fixed;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 10;
        }

        .spell-btn {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .spell-btn.unlocked {
            animation: unlockPulse 0.5s ease;
        }

        @keyframes unlockPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.08); box-shadow: 0 0 20px currentColor; }
            100% { transform: scale(1); }
        }

        .spell-btn:hover:not(:disabled) {
            transform: scale(1.05);
        }

        .spell-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #spiralBtn {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
            box-shadow: 0 0 12px rgba(155, 89, 182, 0.5);
        }

        #pulseBtn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            box-shadow: 0 0 12px rgba(231, 76, 60, 0.5);
        }

        #zapBtn {
            background: linear-gradient(135deg, #f1c40f, #f39c12);
            color: #333;
            box-shadow: 0 0 12px rgba(241, 196, 15, 0.5);
        }

        #suppressBtn {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            color: white;
            box-shadow: 0 0 12px rgba(149, 165, 166, 0.5);
        }

        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
        }

        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 30px currentColor;
        }

        #gameOver.win h1 {
            color: #2ecc71;
        }

        #gameOver.lose h1 {
            color: #e74c3c;
        }

        #restartBtn {
            padding: 15px 40px;
            font-size: 24px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #restartBtn:hover {
            transform: scale(1.1);
        }

        #clashResult {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: white;
            text-shadow: 0 0 20px white;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 50;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="controls">
        <button id="suppressBtn" class="spell-btn">SUPPRESS</button>
        <button id="spiralBtn" class="spell-btn">Spiral</button>
        <button id="pulseBtn" class="spell-btn">Pulse</button>
        <button id="zapBtn" class="spell-btn">Zap</button>
    </div>

    <div id="clashResult"></div>

    <div id="gameOver">
        <h1 id="gameOverText"></h1>
        <button id="restartBtn">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const suppressBtn = document.getElementById('suppressBtn');
        const spiralBtn = document.getElementById('spiralBtn');
        const pulseBtn = document.getElementById('pulseBtn');
        const zapBtn = document.getElementById('zapBtn');
        const gameOverScreen = document.getElementById('gameOver');
        const gameOverText = document.getElementById('gameOverText');
        const restartBtn = document.getElementById('restartBtn');
        const clashResult = document.getElementById('clashResult');

        // Game state
        let ballPosition = 50; // 0-100, starts at center
        let playerChoice = 'suppress'; // Will be overridden by center beam type at game start
        let lastClashTime = 0;
        let clashInterval = 2000; // 2 seconds
        let gameActive = true;
        let animationTime = 0;

        // HP System (FTL-style pips)
        const MAX_HP = 30;
        let playerHP = MAX_HP;
        let enemyHP = MAX_HP;

        // Targeting mode state (for Mana Shards)
        let hoveredEnemyNode = null;  // Currently hovered enemy node name

        // Mana Shards projectile system
        let manaShardProjectile = null;  // Active projectile or null
        const projectileTravelTime = 850; // ~0.85 seconds
        let projectileTrailParticles = [];  // Separate particle array for trail
        let manaShardImpactFlash = null;  // Impact flash effect state

        // Enemy AI state (sticky random)
        let enemyCurrentBeam = null;
        let enemyClashesRemaining = 0;

        // Collision effects
        let particles = [];
        let clashFlashIntensity = 0;
        let lastClashResult = 0; // -1, 0, or 1

        // ============================================
        // NODE NETWORK SYSTEM
        // ============================================

        // Node types
        const NODE_TYPE_FUNCTIONAL = 'functional'; // Can be activated (head, center, hands, feet)
        const NODE_TYPE_PATHWAY = 'pathway';       // Transit only (neck, shoulders, elbows, hips, knees)

        // All nodes in the network
        const nodeNetwork = {
            centerX: 0,
            centerY: 0,
            scale: 1.5,  // 50% larger
            functionalRadius: 21,  // Larger for functional nodes (14 * 1.5)
            pathwayRadius: 9,      // Smaller for pathway nodes (6 * 1.5)

            // Node definitions: position offsets and type
            nodes: {
                // Functional nodes (6) - can be activated
                head:       { x: 0, y: -85, type: NODE_TYPE_FUNCTIONAL },
                center:     { x: 0, y: -20, type: NODE_TYPE_FUNCTIONAL },
                leftHand:   { x: -75, y: -15, type: NODE_TYPE_FUNCTIONAL },
                rightHand:  { x: 75, y: -15, type: NODE_TYPE_FUNCTIONAL },
                leftFoot:   { x: -30, y: 85, type: NODE_TYPE_FUNCTIONAL },
                rightFoot:  { x: 30, y: 85, type: NODE_TYPE_FUNCTIONAL },

                // Pathway nodes (9) - transit only
                neck:           { x: 0, y: -60, type: NODE_TYPE_PATHWAY },
                leftShoulder:   { x: -25, y: -35, type: NODE_TYPE_PATHWAY },
                rightShoulder:  { x: 25, y: -35, type: NODE_TYPE_PATHWAY },
                leftElbow:      { x: -50, y: -25, type: NODE_TYPE_PATHWAY },
                rightElbow:     { x: 50, y: -25, type: NODE_TYPE_PATHWAY },
                leftHip:        { x: -15, y: 20, type: NODE_TYPE_PATHWAY },
                rightHip:       { x: 15, y: 20, type: NODE_TYPE_PATHWAY },
                leftKnee:       { x: -25, y: 55, type: NODE_TYPE_PATHWAY },
                rightKnee:      { x: 25, y: 55, type: NODE_TYPE_PATHWAY }
            },

            // Adjacency list - which nodes connect to which
            connections: {
                // Head path
                head: ['neck'],
                neck: ['head', 'center'],

                // Center connects to neck and all limb starts
                center: ['neck', 'leftShoulder', 'rightShoulder', 'leftHip', 'rightHip'],

                // Left arm path
                leftShoulder: ['center', 'leftElbow'],
                leftElbow: ['leftShoulder', 'leftHand'],
                leftHand: ['leftElbow'],

                // Right arm path
                rightShoulder: ['center', 'rightElbow'],
                rightElbow: ['rightShoulder', 'rightHand'],
                rightHand: ['rightElbow'],

                // Left leg path
                leftHip: ['center', 'leftKnee'],
                leftKnee: ['leftHip', 'leftFoot'],
                leftFoot: ['leftKnee'],

                // Right leg path
                rightHip: ['center', 'rightKnee'],
                rightKnee: ['rightHip', 'rightFoot'],
                rightFoot: ['rightKnee']
            },

            // Spell assignments for functional nodes
            spellAssignments: {}
        };

        // Enemy node network (mirrored, display only for now)
        const enemyNodeNetwork = {
            centerX: 0,
            centerY: 0,
            scale: 1.5,  // Same scale as player
            functionalRadius: 21,
            pathwayRadius: 9,

            // Node definitions: mirrored positions (x flipped)
            nodes: {
                // Functional nodes (6)
                head:       { x: 0, y: -85, type: NODE_TYPE_FUNCTIONAL },
                center:     { x: 0, y: -20, type: NODE_TYPE_FUNCTIONAL },
                leftHand:   { x: 75, y: -15, type: NODE_TYPE_FUNCTIONAL },  // Mirrored
                rightHand:  { x: -75, y: -15, type: NODE_TYPE_FUNCTIONAL }, // Mirrored
                leftFoot:   { x: 30, y: 85, type: NODE_TYPE_FUNCTIONAL },   // Mirrored
                rightFoot:  { x: -30, y: 85, type: NODE_TYPE_FUNCTIONAL },  // Mirrored

                // Pathway nodes (9) - mirrored
                neck:           { x: 0, y: -60, type: NODE_TYPE_PATHWAY },
                leftShoulder:   { x: 25, y: -35, type: NODE_TYPE_PATHWAY },  // Mirrored
                rightShoulder:  { x: -25, y: -35, type: NODE_TYPE_PATHWAY }, // Mirrored
                leftElbow:      { x: 50, y: -25, type: NODE_TYPE_PATHWAY },  // Mirrored
                rightElbow:     { x: -50, y: -25, type: NODE_TYPE_PATHWAY }, // Mirrored
                leftHip:        { x: 15, y: 20, type: NODE_TYPE_PATHWAY },   // Mirrored
                rightHip:       { x: -15, y: 20, type: NODE_TYPE_PATHWAY },  // Mirrored
                leftKnee:       { x: 25, y: 55, type: NODE_TYPE_PATHWAY },   // Mirrored
                rightKnee:      { x: -25, y: 55, type: NODE_TYPE_PATHWAY }   // Mirrored
            },

            // Same connections as player
            connections: {
                head: ['neck'],
                neck: ['head', 'center'],
                center: ['neck', 'leftShoulder', 'rightShoulder', 'leftHip', 'rightHip'],
                leftShoulder: ['center', 'leftElbow'],
                leftElbow: ['leftShoulder', 'leftHand'],
                leftHand: ['leftElbow'],
                rightShoulder: ['center', 'rightElbow'],
                rightElbow: ['rightShoulder', 'rightHand'],
                rightHand: ['rightElbow'],
                leftHip: ['center', 'leftKnee'],
                leftKnee: ['leftHip', 'leftFoot'],
                leftFoot: ['leftKnee'],
                rightHip: ['center', 'rightKnee'],
                rightKnee: ['rightHip', 'rightFoot'],
                rightFoot: ['rightKnee']
            },

            // Spell assignments (separate random from player)
            spellAssignments: {}
        };

        // Enemy node names (same structure as player)
        const enemyNodeNames = Object.keys(enemyNodeNetwork.nodes);
        const enemyFunctionalNodeNames = enemyNodeNames.filter(n => enemyNodeNetwork.nodes[n].type === NODE_TYPE_FUNCTIONAL);
        const enemyPathwayNodeNames = enemyNodeNames.filter(n => enemyNodeNetwork.nodes[n].type === NODE_TYPE_PATHWAY);

        // Enemy node states and activation tracking
        let enemyNodeStates = {};
        let enemyNodeActivationProgress = {};
        let enemyNodeActivationStartTime = {};
        let enemyNodeDamaged = {};  // Track which nodes are damaged (true/false)
        let enemyNodeRepairing = {};  // Track which nodes are being repaired
        let enemyNodeRepairProgress = {};
        let enemyNodeRepairStartTime = {};
        const enemyNodeRepairTime = 3000;  // 3 seconds to repair

        // Enemy awareness state - mirrors player awareness system
        let enemyAwarenessPos = { x: 0, y: 0 };
        let enemyAwarenessAtNode = 'center';
        let enemyAwarenessPath = [];
        let enemyAwarenessPathIndex = 0;
        let enemyAwarenessMoving = false;
        let enemyAwarenessMoveStartTime = 0;
        let enemyAwarenessMoveStartPos = { x: 0, y: 0 };
        let enemyAwarenessCurrentTarget = null;
        const enemyAwarenessStepTime = 1000;   // 1s per step (player has 300ms) - ~3x slower travel

        // Enemy AI state
        let enemyAINextDecisionTime = 0;
        const enemyAIDecisionDelay = 500;  // Wait 0.5s after arriving before picking next target

        // Enemy node activation time (3x slower than player)
        const enemyNodeActivationTime = 6000; // 6 seconds (player has 2 seconds)

        // Enemy active mana (now dynamic, starts at 0)
        let enemyActiveMana = 0;

        // List of all node names
        const allNodeNames = Object.keys(nodeNetwork.nodes);
        const functionalNodeNames = allNodeNames.filter(n => nodeNetwork.nodes[n].type === NODE_TYPE_FUNCTIONAL);
        const pathwayNodeNames = allNodeNames.filter(n => nodeNetwork.nodes[n].type === NODE_TYPE_PATHWAY);

        // Awareness state - now includes path following
        let awarenessPos = { x: 0, y: 0 };
        let awarenessAtNode = 'center';
        let awarenessPath = [];           // Array of nodes to traverse
        let awarenessPathIndex = 0;       // Current position in path
        let awarenessMoving = false;
        let awarenessMoveStartTime = 0;
        let awarenessMoveStartPos = { x: 0, y: 0 };
        let awarenessCurrentTarget = null; // Current immediate target node
        const awarenessStepTime = 300;    // Time to move between adjacent nodes (faster!)

        // Node activation state (only for functional nodes)
        // States: 'dormant', 'activating', 'active'
        let nodeStates = {};
        let nodeActivationProgress = {};
        let nodeActivationStartTime = {};
        let nodeDamaged = {};  // Track which player nodes are damaged
        const nodeActivationTime = 2000; // 2 seconds to activate

        // Mana Shards charging state
        // States: 'idle' (active but not charging), 'charging', 'charged' (ready to fire)
        let manaShardsState = 'idle';
        let manaShardsChargeProgress = 0;
        let manaShardsChargeStartTime = 0;
        const manaShardsChargeTime = 3000; // 3 seconds to fully charge
        let manaShardsNodeName = null; // Which node has Mana Shards (set during init)

        // Active mana counters
        let playerActiveMana = 0;
        // enemyActiveMana is now declared above with enemy awareness state (starts at 0)

        // Beam type commitment system
        let playerBeamType = null; // Currently committed beam type
        let enemyBeamType = null; // Enemy's current beam type
        let enemyBeamSwitchTime = 0; // When enemy will switch beams
        const enemyBeamDuration = 4000 + Math.random() * 4000; // 4-8 seconds between switches
        const counterDebuff = 3; // Base debuff when countered
        const maxManaDebuff = 6; // Doubled debuff when counter-er is at max mana (6)

        // Cooldown system
        let cooldowns = {
            suppress: 0,
            spiral: 0,
            pulse: 0,
            zap: 0
        };
        const cooldownDuration = 5000; // 5 seconds commitment

        // Track previous unlock states for animation
        let previousUnlockStates = {
            spiral: false,
            pulse: false,
            zap: false
        };

        // Beam thickness based on mana (0-6 mana maps to min-max thickness)
        const BEAM_THICKNESS_MIN = 8;
        const BEAM_THICKNESS_MAX = 45;

        function getBeamThickness(mana) {
            // Clamp mana to 0-6 range
            const clampedMana = Math.max(0, Math.min(6, mana));
            // Linear interpolation from min to max
            return BEAM_THICKNESS_MIN + (clampedMana / 6) * (BEAM_THICKNESS_MAX - BEAM_THICKNESS_MIN);
        }

        // Rock-paper-scissors: returns 1 if a beats b, -1 if b beats a, 0 if tie/neutral
        function getCounterResult(a, b) {
            // Neutral always gives 0 modifier (no bonus, no penalty)
            if (a === SUPPRESS || b === SUPPRESS) return 0;
            if (a === b) return 0;
            if ((a === SPIRAL && b === ZAP) ||
                (a === ZAP && b === PULSE) ||
                (a === PULSE && b === SPIRAL)) {
                return 1; // a beats b
            }
            return -1; // b beats a
        }

        // Get debuff applied to ENEMY when player counters them
        // Returns positive number (amount to subtract from enemy mana)
        function getEnemyManaDebuff() {
            if (!playerBeamType || !enemyBeamType) return 0;
            const result = getCounterResult(playerBeamType, enemyBeamType);
            if (result === 1) {
                // Player counters enemy - enemy gets debuffed
                // Double debuff if player is at max mana
                return playerActiveMana >= 6 ? maxManaDebuff : counterDebuff;
            }
            return 0;
        }

        // Get debuff applied to PLAYER when enemy counters them
        // Returns positive number (amount to subtract from player mana)
        function getPlayerManaDebuff() {
            if (!playerBeamType || !enemyBeamType) return 0;
            const result = getCounterResult(playerBeamType, enemyBeamType);
            if (result === -1) {
                // Enemy counters player - player gets debuffed
                // Double debuff if enemy is at max mana
                return enemyActiveMana >= 6 ? maxManaDebuff : counterDebuff;
            }
            return 0;
        }

        // Legacy function for compatibility - now returns 0 since we use debuffs
        function getCounterModifier() {
            return 0; // No longer used - see getPlayerManaDebuff/getEnemyManaDebuff
        }

        // ============================================
        // PATHFINDING (BFS for shortest path)
        // ============================================

        function findPath(startNode, endNode) {
            if (startNode === endNode) return [startNode];
            if (!startNode || !endNode) return [];

            const visited = new Set();
            const queue = [[startNode]];
            visited.add(startNode);

            while (queue.length > 0) {
                const path = queue.shift();
                const currentNode = path[path.length - 1];

                const neighbors = nodeNetwork.connections[currentNode] || [];
                for (const neighbor of neighbors) {
                    if (neighbor === endNode) {
                        return [...path, neighbor];
                    }
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push([...path, neighbor]);
                    }
                }
            }

            return []; // No path found
        }

        // ============================================
        // NODE STATE FUNCTIONS
        // ============================================

        // Initialize node states (only functional nodes can be activated)
        function initNodeStates() {
            nodeStates = {};
            nodeActivationProgress = {};
            nodeActivationStartTime = {};
            nodeDamaged = {};

            functionalNodeNames.forEach(name => {
                nodeDamaged[name] = false;
                if (name === 'center') {
                    // Center node starts ACTIVE - gives immediate beam type
                    nodeStates[name] = 'active';
                    nodeActivationProgress[name] = 1;
                } else {
                    nodeStates[name] = 'dormant';
                    nodeActivationProgress[name] = 0;
                }
            });

            // Start with 1 active mana from center node
            playerActiveMana = 1;
        }

        // Start activating a node (only for functional nodes)
        function startNodeActivation(nodeName) {
            // Only functional nodes can be activated
            if (nodeNetwork.nodes[nodeName]?.type !== NODE_TYPE_FUNCTIONAL) return;

            if (nodeStates[nodeName] === 'dormant') {
                nodeStates[nodeName] = 'activating';
                nodeActivationStartTime[nodeName] = performance.now();
                nodeActivationProgress[nodeName] = 0;
            }
        }

        // Update node activation progress (call each frame)
        function updateNodeActivation(timestamp) {
            functionalNodeNames.forEach(nodeName => {
                if (nodeStates[nodeName] === 'activating') {
                    // Only progress if awareness is at this node
                    if (awarenessAtNode === nodeName) {
                        const elapsed = timestamp - nodeActivationStartTime[nodeName];
                        nodeActivationProgress[nodeName] = Math.min(1, elapsed / nodeActivationTime);

                        if (nodeActivationProgress[nodeName] >= 1) {
                            nodeStates[nodeName] = 'active';
                            playerActiveMana = Math.min(6, playerActiveMana + 1);
                        }
                    }
                }
            });
        }

        // Update Mana Shards charging progress
        function updateManaShardsCharging(timestamp) {
            if (manaShardsState === 'charging') {
                // Only progress if awareness is at the Mana Shards node
                if (awarenessAtNode === manaShardsNodeName) {
                    const elapsed = timestamp - manaShardsChargeStartTime;
                    manaShardsChargeProgress = Math.min(1, elapsed / manaShardsChargeTime);

                    if (manaShardsChargeProgress >= 1) {
                        manaShardsState = 'charged';
                    }
                } else {
                    // Awareness left - pause charging (reset timer for when they return)
                    // Progress is preserved, but timer will restart
                    manaShardsChargeStartTime = timestamp - (manaShardsChargeProgress * manaShardsChargeTime);
                }
            }
        }

        // Check if Mana Shards is currently draining mana (charging or charged)
        function isManaShardsDrawingMana() {
            return manaShardsState === 'charging' || manaShardsState === 'charged';
        }

        // Initialize spell assignments for functional nodes
        function initStickFigureNodes() {
            const beamSpells = [SPIRAL, PULSE, ZAP];

            // Center node ALWAYS gets a beam type
            const shuffledBeamSpells = [...beamSpells].sort(() => Math.random() - 0.5);
            const centerBeamType = shuffledBeamSpells[0];
            const remainingBeamTypes = shuffledBeamSpells.slice(1); // 2 remaining beam types

            // Get non-center functional nodes and shuffle them
            const nonCenterNodes = functionalNodeNames.filter(n => n !== 'center');
            const shuffledNonCenterNodes = [...nonCenterNodes].sort(() => Math.random() - 0.5);

            // Distribution: center gets beam type, remaining 5 nodes get:
            // 1 Mana Shards, 2 remaining beam types, 2 duds
            nodeNetwork.spellAssignments = {};
            manaShardsNodeName = null;

            // Assign center node its beam type
            nodeNetwork.spellAssignments['center'] = centerBeamType;

            // Assign remaining nodes
            shuffledNonCenterNodes.forEach((nodeName, index) => {
                if (index === 0) {
                    nodeNetwork.spellAssignments[nodeName] = MANA_SHARDS;
                    manaShardsNodeName = nodeName; // Track which node has Mana Shards
                } else if (index <= 2) {
                    nodeNetwork.spellAssignments[nodeName] = remainingBeamTypes[index - 1];
                } else {
                    nodeNetwork.spellAssignments[nodeName] = 'dud';
                }
            });

            // Reset Mana Shards charging state
            manaShardsState = 'idle';
            manaShardsChargeProgress = 0;
        }

        // Initialize enemy node network (display only - separate random assignment)
        function initEnemyNodeNetwork() {
            const beamSpells = [SPIRAL, PULSE, ZAP];

            // Center node ALWAYS gets a beam type (independent random from player)
            const shuffledBeamSpells = [...beamSpells].sort(() => Math.random() - 0.5);
            const centerBeamType = shuffledBeamSpells[0];
            const remainingBeamTypes = shuffledBeamSpells.slice(1); // 2 remaining beam types

            // Get non-center functional nodes and shuffle them
            const nonCenterNodes = enemyFunctionalNodeNames.filter(n => n !== 'center');
            const shuffledNonCenterNodes = [...nonCenterNodes].sort(() => Math.random() - 0.5);

            // Distribution: center gets beam type, remaining 5 nodes get:
            // 1 Mana Shards, 2 remaining beam types, 2 duds
            enemyNodeNetwork.spellAssignments = {};

            // Assign center node its beam type
            enemyNodeNetwork.spellAssignments['center'] = centerBeamType;

            // Assign remaining nodes
            shuffledNonCenterNodes.forEach((nodeName, index) => {
                if (index === 0) {
                    enemyNodeNetwork.spellAssignments[nodeName] = MANA_SHARDS;
                } else if (index <= 2) {
                    enemyNodeNetwork.spellAssignments[nodeName] = remainingBeamTypes[index - 1];
                } else {
                    enemyNodeNetwork.spellAssignments[nodeName] = 'dud';
                }
            });

            // Initialize enemy nodes - center starts ACTIVE
            enemyNodeStates = {};
            enemyNodeDamaged = {};
            enemyNodeRepairing = {};
            enemyNodeRepairProgress = {};
            enemyNodeRepairStartTime = {};
            enemyFunctionalNodeNames.forEach(name => {
                if (name === 'center') {
                    // Center node starts ACTIVE - gives immediate beam type
                    enemyNodeStates[name] = 'active';
                    enemyNodeActivationProgress[name] = 1;
                } else {
                    enemyNodeStates[name] = 'dormant';
                    enemyNodeActivationProgress[name] = 0;
                }
                enemyNodeDamaged[name] = false;
                enemyNodeRepairing[name] = false;
                enemyNodeRepairProgress[name] = 0;
            });
            // Also initialize pathway nodes as not damaged
            enemyPathwayNodeNames.forEach(name => {
                enemyNodeDamaged[name] = false;
                enemyNodeRepairing[name] = false;
                enemyNodeRepairProgress[name] = 0;
            });

            // Start with 1 active mana from center node
            enemyActiveMana = 1;
        }

        // ============================================
        // ENEMY AWARENESS & AI SYSTEM
        // ============================================

        // Initialize enemy awareness at center node
        function initEnemyAwareness() {
            enemyAwarenessAtNode = 'center';
            enemyAwarenessPath = [];
            enemyAwarenessPathIndex = 0;
            enemyAwarenessMoving = false;
            enemyAwarenessCurrentTarget = null;
            enemyAINextDecisionTime = performance.now() + 1000; // Wait 1s before first move
            // Start activating the center node
            startEnemyNodeActivation('center');
        }

        // Start activating or repairing an enemy node
        function startEnemyNodeActivation(nodeName) {
            if (enemyNodeNetwork.nodes[nodeName]?.type !== NODE_TYPE_FUNCTIONAL) return;

            // Check if node is damaged - start repair instead of activation
            if (enemyNodeDamaged[nodeName]) {
                if (!enemyNodeRepairing[nodeName]) {
                    startEnemyNodeRepair(nodeName);
                }
                return;
            }

            if (enemyNodeStates[nodeName] === 'dormant') {
                enemyNodeStates[nodeName] = 'activating';
                enemyNodeActivationStartTime[nodeName] = performance.now();
                enemyNodeActivationProgress[nodeName] = 0;
            }
        }

        // Start repairing a damaged enemy node
        function startEnemyNodeRepair(nodeName) {
            if (!enemyNodeDamaged[nodeName]) return;
            if (enemyNodeRepairing[nodeName]) return;

            enemyNodeRepairing[nodeName] = true;
            enemyNodeRepairStartTime[nodeName] = performance.now();
            enemyNodeRepairProgress[nodeName] = 0;
            console.log(`[ENEMY REPAIR] Started repairing: ${nodeName}`);
        }

        // Update enemy node repair progress
        function updateEnemyNodeRepair(timestamp) {
            enemyFunctionalNodeNames.forEach(nodeName => {
                if (enemyNodeRepairing[nodeName]) {
                    // Only progress if enemy awareness is at this node
                    if (enemyAwarenessAtNode === nodeName) {
                        const elapsed = timestamp - enemyNodeRepairStartTime[nodeName];
                        enemyNodeRepairProgress[nodeName] = Math.min(1, elapsed / enemyNodeRepairTime);

                        if (enemyNodeRepairProgress[nodeName] >= 1) {
                            // Repair complete!
                            enemyNodeDamaged[nodeName] = false;
                            enemyNodeRepairing[nodeName] = false;
                            enemyNodeRepairProgress[nodeName] = 0;

                            // If node was active, remove the -1 mana penalty
                            if (enemyNodeStates[nodeName] === 'active') {
                                enemyActiveMana = enemyActiveMana + 1; // Remove -1 penalty (was -1, now 0)
                                // Set to dormant - must reactivate
                                enemyNodeStates[nodeName] = 'dormant';
                                // Actually net change is +1 (from -1 to 0), but node goes dormant
                            } else {
                                // Node was dormant or activating, just clear damage
                                enemyNodeStates[nodeName] = 'dormant';
                            }

                            console.log(`[ENEMY REPAIR] Repair complete: ${nodeName} - now dormant`);
                        }
                    } else {
                        // Awareness left - pause repair (preserve progress but reset timer)
                        enemyNodeRepairStartTime[nodeName] = timestamp - (enemyNodeRepairProgress[nodeName] * enemyNodeRepairTime);
                    }
                }
            });

            // Also handle pathway nodes (visual repair only, no mana effect)
            enemyPathwayNodeNames.forEach(nodeName => {
                if (enemyNodeRepairing[nodeName]) {
                    if (enemyAwarenessAtNode === nodeName) {
                        const elapsed = timestamp - enemyNodeRepairStartTime[nodeName];
                        enemyNodeRepairProgress[nodeName] = Math.min(1, elapsed / enemyNodeRepairTime);

                        if (enemyNodeRepairProgress[nodeName] >= 1) {
                            enemyNodeDamaged[nodeName] = false;
                            enemyNodeRepairing[nodeName] = false;
                            enemyNodeRepairProgress[nodeName] = 0;
                            console.log(`[ENEMY REPAIR] Pathway repair complete: ${nodeName}`);
                        }
                    } else {
                        enemyNodeRepairStartTime[nodeName] = timestamp - (enemyNodeRepairProgress[nodeName] * enemyNodeRepairTime);
                    }
                }
            });
        }

        // Update enemy node activation progress
        function updateEnemyNodeActivation(timestamp) {
            enemyFunctionalNodeNames.forEach(nodeName => {
                if (enemyNodeStates[nodeName] === 'activating') {
                    // Only progress if enemy awareness is at this node
                    if (enemyAwarenessAtNode === nodeName) {
                        const elapsed = timestamp - enemyNodeActivationStartTime[nodeName];
                        enemyNodeActivationProgress[nodeName] = Math.min(1, elapsed / enemyNodeActivationTime);

                        if (enemyNodeActivationProgress[nodeName] >= 1) {
                            enemyNodeStates[nodeName] = 'active';
                            // Damaged nodes contribute -1 mana, healthy nodes +1
                            if (enemyNodeDamaged[nodeName]) {
                                enemyActiveMana = enemyActiveMana - 1;
                            } else {
                                enemyActiveMana = Math.min(6, enemyActiveMana + 1);
                            }
                        }
                    }
                }
            });
        }

        // Find path for enemy awareness (uses same BFS as player)
        function findEnemyPath(startNode, endNode) {
            if (startNode === endNode) return [startNode];
            if (!startNode || !endNode) return [];

            const visited = new Set();
            const queue = [[startNode]];
            visited.add(startNode);

            while (queue.length > 0) {
                const path = queue.shift();
                const currentNode = path[path.length - 1];

                const neighbors = enemyNodeNetwork.connections[currentNode] || [];
                for (const neighbor of neighbors) {
                    if (neighbor === endNode) {
                        return [...path, neighbor];
                    }
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push([...path, neighbor]);
                    }
                }
            }

            return [];
        }

        // Move enemy awareness to a target node
        function moveEnemyAwarenessTo(targetNode) {
            if (enemyAwarenessMoving) return;
            if (enemyAwarenessAtNode === targetNode) return;
            if (!enemyAwarenessAtNode) return;

            const path = findEnemyPath(enemyAwarenessAtNode, targetNode);
            if (path.length < 2) return;

            enemyAwarenessPath = path.slice(1);
            enemyAwarenessPathIndex = 0;
            enemyAwarenessCurrentTarget = enemyAwarenessPath[0];
            enemyAwarenessMoving = true;
            enemyAwarenessMoveStartTime = performance.now();
            enemyAwarenessMoveStartPos = { ...enemyAwarenessPos };
            enemyAwarenessAtNode = null;
        }

        // Update enemy awareness position
        function updateEnemyAwareness(timestamp) {
            // Update network center position
            enemyNodeNetwork.centerX = canvas.width - 160;
            enemyNodeNetwork.centerY = canvas.height - 185;

            if (enemyAwarenessMoving && enemyAwarenessPath.length > 0) {
                const elapsed = timestamp - enemyAwarenessMoveStartTime;
                const progress = Math.min(1, elapsed / enemyAwarenessStepTime);
                const eased = 1 - Math.pow(1 - progress, 2);

                const targetPos = getEnemyNodePosition(enemyAwarenessCurrentTarget);
                enemyAwarenessPos.x = enemyAwarenessMoveStartPos.x + (targetPos.x - enemyAwarenessMoveStartPos.x) * eased;
                enemyAwarenessPos.y = enemyAwarenessMoveStartPos.y + (targetPos.y - enemyAwarenessMoveStartPos.y) * eased;

                if (progress >= 1) {
                    enemyAwarenessAtNode = enemyAwarenessCurrentTarget;
                    enemyAwarenessPos = { ...targetPos };
                    enemyAwarenessPathIndex++;

                    if (enemyAwarenessPathIndex < enemyAwarenessPath.length) {
                        enemyAwarenessCurrentTarget = enemyAwarenessPath[enemyAwarenessPathIndex];
                        enemyAwarenessMoveStartTime = timestamp;
                        enemyAwarenessMoveStartPos = { ...enemyAwarenessPos };
                    } else {
                        enemyAwarenessMoving = false;
                        enemyAwarenessPath = [];
                        enemyAwarenessPathIndex = 0;
                        enemyAwarenessCurrentTarget = null;

                        // Start activating if it's a functional node, or repair if damaged
                        startEnemyNodeActivation(enemyAwarenessAtNode);

                        // Also check if it's a damaged pathway node - start repair
                        if (enemyNodeDamaged[enemyAwarenessAtNode] && !enemyNodeRepairing[enemyAwarenessAtNode]) {
                            const nodeInfo = enemyNodeNetwork.nodes[enemyAwarenessAtNode];
                            if (nodeInfo && nodeInfo.type === NODE_TYPE_PATHWAY) {
                                enemyNodeRepairing[enemyAwarenessAtNode] = true;
                                enemyNodeRepairStartTime[enemyAwarenessAtNode] = performance.now();
                                enemyNodeRepairProgress[enemyAwarenessAtNode] = 0;
                                console.log(`[ENEMY REPAIR] Started repairing pathway: ${enemyAwarenessAtNode}`);
                            }
                        }

                        // Schedule next AI decision
                        enemyAINextDecisionTime = timestamp + enemyAIDecisionDelay;
                    }
                }
            } else if (!enemyAwarenessMoving && enemyAwarenessAtNode) {
                const currentPos = getEnemyNodePosition(enemyAwarenessAtNode);
                enemyAwarenessPos = { ...currentPos };
            }
        }

        // Enemy AI: Pick next target node
        function enemyAIPickTarget() {
            // Priority 1: Damaged functional nodes that need repair
            const damagedFunctionalNodes = enemyFunctionalNodeNames.filter(name =>
                enemyNodeDamaged[name] && !enemyNodeRepairing[name]
            );
            if (damagedFunctionalNodes.length > 0) {
                // High priority: repair damaged nodes (especially active ones bleeding mana)
                const bleedingNodes = damagedFunctionalNodes.filter(name =>
                    enemyNodeStates[name] === 'active'
                );
                if (bleedingNodes.length > 0 && Math.random() < 0.8) {
                    return bleedingNodes[Math.floor(Math.random() * bleedingNodes.length)];
                }
                if (Math.random() < 0.5) {
                    return damagedFunctionalNodes[Math.floor(Math.random() * damagedFunctionalNodes.length)];
                }
            }

            // Priority 2: Inactive functional nodes (dormant, need activation)
            const inactiveNodes = enemyFunctionalNodeNames.filter(name =>
                enemyNodeStates[name] !== 'active' && !enemyNodeDamaged[name]
            );

            if (inactiveNodes.length === 0) {
                // Check for damaged nodes as fallback
                if (damagedFunctionalNodes.length > 0) {
                    return damagedFunctionalNodes[Math.floor(Math.random() * damagedFunctionalNodes.length)];
                }
                return null;
            }

            // Prioritize spell nodes over duds
            const spellNodes = inactiveNodes.filter(name =>
                enemyNodeNetwork.spellAssignments[name] !== 'dud'
            );
            const dudNodes = inactiveNodes.filter(name =>
                enemyNodeNetwork.spellAssignments[name] === 'dud'
            );

            // 70% chance to pick spell node if available, otherwise dud
            let candidates = spellNodes.length > 0 && Math.random() < 0.7 ? spellNodes : inactiveNodes;

            // Pick random from candidates
            return candidates[Math.floor(Math.random() * candidates.length)];
        }

        // Update enemy AI decision making
        function updateEnemyAI(timestamp) {
            if (!gameActive) return;

            // Only make decisions when not moving and it's time
            if (!enemyAwarenessMoving && timestamp >= enemyAINextDecisionTime) {
                // Check if current node is still activating
                if (enemyAwarenessAtNode && enemyNodeStates[enemyAwarenessAtNode] === 'activating') {
                    // Stay and wait for activation to complete
                    return;
                }

                // Check if current node is repairing
                if (enemyAwarenessAtNode && enemyNodeRepairing[enemyAwarenessAtNode]) {
                    // Stay and wait for repair to complete
                    return;
                }

                // Pick next target
                const target = enemyAIPickTarget();
                if (target && target !== enemyAwarenessAtNode) {
                    moveEnemyAwarenessTo(target);
                } else {
                    // No valid targets or already there, check again later
                    enemyAINextDecisionTime = timestamp + 1000;
                }
            }
        }

        // Get color for a node based on its spell assignment
        function getNodeColor(nodeName) {
            const nodeInfo = nodeNetwork.nodes[nodeName];
            if (!nodeInfo) return '#666666';

            // Pathway nodes are always grey
            if (nodeInfo.type === NODE_TYPE_PATHWAY) return '#555555';

            // Functional nodes get spell color or dud grey
            const spell = nodeNetwork.spellAssignments[nodeName];
            if (spell === 'dud') return '#666666';
            return colors[spell] || '#666666';
        }

        // Get node world position
        function getNodePosition(nodeName) {
            const nodeInfo = nodeNetwork.nodes[nodeName];
            if (!nodeInfo) return { x: 0, y: 0 };

            return {
                x: nodeNetwork.centerX + nodeInfo.x * nodeNetwork.scale,
                y: nodeNetwork.centerY + nodeInfo.y * nodeNetwork.scale
            };
        }

        // Get node radius based on type
        function getNodeRadius(nodeName) {
            const nodeInfo = nodeNetwork.nodes[nodeName];
            if (!nodeInfo) return nodeNetwork.pathwayRadius;

            return nodeInfo.type === NODE_TYPE_FUNCTIONAL
                ? nodeNetwork.functionalRadius
                : nodeNetwork.pathwayRadius;
        }

        // ============================================
        // AWARENESS MOVEMENT (PATH-BASED)
        // ============================================

        // Initialize awareness at center node
        function initStickAwareness() {
            awarenessAtNode = 'center';
            awarenessPath = [];
            awarenessPathIndex = 0;
            awarenessMoving = false;
            awarenessCurrentTarget = null;
            // Start activating the center node since awareness begins there
            startNodeActivation('center');
        }

        // Update awareness position (follows path step by step)
        function updateStickAwareness(timestamp) {
            // Update network center position
            // Position below player wizard (left side)
            nodeNetwork.centerX = 160;
            nodeNetwork.centerY = canvas.height - 185;

            if (awarenessMoving && awarenessPath.length > 0) {
                const elapsed = timestamp - awarenessMoveStartTime;
                const progress = Math.min(1, elapsed / awarenessStepTime);
                // Ease out for smooth movement
                const eased = 1 - Math.pow(1 - progress, 2);

                const targetPos = getNodePosition(awarenessCurrentTarget);
                awarenessPos.x = awarenessMoveStartPos.x + (targetPos.x - awarenessMoveStartPos.x) * eased;
                awarenessPos.y = awarenessMoveStartPos.y + (targetPos.y - awarenessMoveStartPos.y) * eased;

                if (progress >= 1) {
                    // Arrived at current target node
                    awarenessAtNode = awarenessCurrentTarget;
                    awarenessPos = { ...targetPos };
                    awarenessPathIndex++;

                    // Check if there are more nodes in the path
                    if (awarenessPathIndex < awarenessPath.length) {
                        // Move to next node in path
                        awarenessCurrentTarget = awarenessPath[awarenessPathIndex];
                        awarenessMoveStartTime = timestamp;
                        awarenessMoveStartPos = { ...awarenessPos };
                    } else {
                        // Reached final destination
                        awarenessMoving = false;
                        awarenessPath = [];
                        awarenessPathIndex = 0;
                        awarenessCurrentTarget = null;

                        // Start activating if it's a functional node
                        startNodeActivation(awarenessAtNode);
                    }
                }
            } else if (!awarenessMoving && awarenessAtNode) {
                // Snap to current node position (in case canvas resized)
                const currentPos = getNodePosition(awarenessAtNode);
                awarenessPos = { ...currentPos };
            }
        }

        // Move awareness to a target node (uses pathfinding)
        function moveStickAwarenessTo(targetNode) {
            if (awarenessMoving) return; // Can't interrupt current movement
            if (awarenessAtNode === targetNode) return; // Already there
            if (!awarenessAtNode) return; // No starting point

            // Find path from current node to target
            const path = findPath(awarenessAtNode, targetNode);
            if (path.length < 2) return; // No valid path or already there

            // Start following the path (skip first node since we're already there)
            awarenessPath = path.slice(1);
            awarenessPathIndex = 0;
            awarenessCurrentTarget = awarenessPath[0];
            awarenessMoving = true;
            awarenessMoveStartTime = performance.now();
            awarenessMoveStartPos = { ...awarenessPos };
            awarenessAtNode = null; // In transit
        }

        // Check if a click hit any node (functional nodes only for interaction)
        function getClickedStickNode(clickX, clickY) {
            // Only allow clicking on functional nodes
            for (const nodeName of functionalNodeNames) {
                const pos = getNodePosition(nodeName);
                const radius = getNodeRadius(nodeName);
                const dist = Math.sqrt(Math.pow(clickX - pos.x, 2) + Math.pow(clickY - pos.y, 2));
                if (dist <= radius + 10) {
                    return nodeName;
                }
            }
            return null;
        }

        // Draw the node network with all connections and nodes
        function drawStickFigure() {
            // Position below player wizard (left side)
            nodeNetwork.centerX = 160;
            nodeNetwork.centerY = canvas.height - 185;

            const cx = nodeNetwork.centerX;
            const cy = nodeNetwork.centerY;

            ctx.save();

            // Draw background panel (scaled up 1.5x)
            ctx.fillStyle = 'rgba(20, 20, 40, 0.7)';
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(cx - 140, cy - 150, 280, 310, 10);
            ctx.fill();
            ctx.stroke();

            // Draw all connections (edges between nodes)
            ctx.strokeStyle = 'rgba(100, 100, 120, 0.6)';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            const drawnEdges = new Set();
            for (const nodeName of allNodeNames) {
                const nodePos = getNodePosition(nodeName);
                const neighbors = nodeNetwork.connections[nodeName] || [];

                for (const neighbor of neighbors) {
                    // Avoid drawing same edge twice
                    const edgeKey = [nodeName, neighbor].sort().join('-');
                    if (drawnEdges.has(edgeKey)) continue;
                    drawnEdges.add(edgeKey);

                    const neighborPos = getNodePosition(neighbor);
                    ctx.beginPath();
                    ctx.moveTo(nodePos.x, nodePos.y);
                    ctx.lineTo(neighborPos.x, neighborPos.y);
                    ctx.stroke();
                }
            }

            // Draw pathway nodes (small grey dots)
            pathwayNodeNames.forEach(nodeName => {
                const pos = getNodePosition(nodeName);
                const radius = getNodeRadius(nodeName);

                // Simple grey dot
                ctx.fillStyle = 'rgba(80, 80, 100, 0.8)';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Subtle outline
                ctx.strokeStyle = 'rgba(120, 120, 140, 0.6)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.stroke();
            });

            // Draw functional nodes (larger, colored)
            functionalNodeNames.forEach(nodeName => {
                const pos = getNodePosition(nodeName);
                const radius = getNodeRadius(nodeName);
                const color = getNodeColor(nodeName);
                const spell = nodeNetwork.spellAssignments[nodeName];
                const state = nodeStates[nodeName] || 'dormant';
                const activationProg = nodeActivationProgress[nodeName] || 0;

                if (state === 'dormant') {
                    // DORMANT: dim, outline only
                    ctx.strokeStyle = hexToRgba(color, 0.4);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Very faint fill
                    ctx.fillStyle = hexToRgba(color, 0.1);
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.fill();

                } else if (state === 'activating') {
                    // ACTIVATING: dim node with circular progress bar
                    ctx.fillStyle = hexToRgba(color, 0.25);
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = hexToRgba(color, 0.5);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Progress bar
                    const progressRadius = radius + 5;
                    const startAngle = -Math.PI / 2;
                    const endAngle = startAngle + (activationProg * Math.PI * 2);

                    ctx.strokeStyle = hexToRgba(color, 0.2);
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, progressRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.strokeStyle = color;
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, progressRadius, startAngle, endAngle);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    ctx.lineCap = 'butt';

                } else if (state === 'active') {
                    // Check if this is Mana Shards node with special charging states
                    const isManaShards = nodeName === manaShardsNodeName;
                    const isCharging = isManaShards && manaShardsState === 'charging';
                    const isCharged = isManaShards && manaShardsState === 'charged';

                    if (isCharging) {
                        // CHARGING: pulsing cyan with charge progress bar
                        const pulseScale = 1 + Math.sin(animationTime * 8) * 0.1;
                        const glowSize = (radius + 15) * pulseScale;

                        // Outer glow - more intense cyan
                        const glowGradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, glowSize);
                        glowGradient.addColorStop(0, 'rgba(0, 212, 255, 0.9)');
                        glowGradient.addColorStop(0.3, 'rgba(0, 212, 255, 0.5)');
                        glowGradient.addColorStop(0.6, 'rgba(0, 180, 255, 0.2)');
                        glowGradient.addColorStop(1, 'rgba(0, 150, 255, 0)');
                        ctx.fillStyle = glowGradient;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, glowSize, 0, Math.PI * 2);
                        ctx.fill();

                        // Core node
                        ctx.fillStyle = color;
                        ctx.shadowColor = '#00ffff';
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;

                        // Charge progress ring
                        const progressRadius = radius + 8;
                        const startAngle = -Math.PI / 2;
                        const endAngle = startAngle + (manaShardsChargeProgress * Math.PI * 2);

                        // Background ring
                        ctx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, progressRadius, 0, Math.PI * 2);
                        ctx.stroke();

                        // Progress ring
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 5;
                        ctx.lineCap = 'round';
                        ctx.shadowColor = '#00ffff';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, progressRadius, startAngle, endAngle);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        ctx.lineCap = 'butt';

                    } else if (isCharged) {
                        // CHARGED: intense pulsing, ready to fire
                        const pulseIntensity = 0.5 + Math.sin(animationTime * 10) * 0.5;
                        const glowSize = radius + 20 + Math.sin(animationTime * 6) * 5;

                        // Intense outer glow
                        const glowGradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, glowSize);
                        glowGradient.addColorStop(0, `rgba(0, 255, 255, ${0.9 * pulseIntensity})`);
                        glowGradient.addColorStop(0.3, `rgba(100, 255, 255, ${0.6 * pulseIntensity})`);
                        glowGradient.addColorStop(0.6, `rgba(0, 200, 255, ${0.3 * pulseIntensity})`);
                        glowGradient.addColorStop(1, 'rgba(0, 150, 255, 0)');
                        ctx.fillStyle = glowGradient;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, glowSize, 0, Math.PI * 2);
                        ctx.fill();

                        // Core node - bright white/cyan
                        ctx.fillStyle = '#00ffff';
                        ctx.shadowColor = '#ffffff';
                        ctx.shadowBlur = 25;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                        ctx.fill();

                        // White hot center
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, radius * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;

                        // Crackling particle effect
                        for (let i = 0; i < 6; i++) {
                            const angle = (animationTime * 3 + i * Math.PI / 3) % (Math.PI * 2);
                            const dist = radius + 10 + Math.sin(animationTime * 15 + i * 2) * 8;
                            const px = pos.x + Math.cos(angle) * dist;
                            const py = pos.y + Math.sin(angle) * dist;
                            const particleSize = 2 + Math.sin(animationTime * 20 + i) * 1;

                            ctx.fillStyle = `rgba(200, 255, 255, ${0.5 + Math.sin(animationTime * 25 + i * 3) * 0.5})`;
                            ctx.beginPath();
                            ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // "READY" indicator ring
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([4, 4]);
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, radius + 12, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);

                    } else {
                        // NORMAL ACTIVE: bright, glowing (default behavior)
                        const glowSize = radius + 10 + Math.sin(animationTime * 4) * 2;
                        const glowGradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, glowSize);
                        glowGradient.addColorStop(0, hexToRgba(color, 0.8));
                        glowGradient.addColorStop(0.4, hexToRgba(color, 0.4));
                        glowGradient.addColorStop(0.7, hexToRgba(color, 0.15));
                        glowGradient.addColorStop(1, hexToRgba(color, 0));
                        ctx.fillStyle = glowGradient;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, glowSize, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = color;
                        ctx.shadowColor = color;
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;

                        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, radius * 0.4, 0, Math.PI * 2);
                        ctx.fill();

                        // Show "CLICK TO CHARGE" hint when awareness is at idle Mana Shards
                        if (isManaShards && manaShardsState === 'idle' && awarenessAtNode === nodeName) {
                            ctx.fillStyle = 'rgba(0, 212, 255, 0.8)';
                            ctx.font = '9px Georgia';
                            ctx.textAlign = 'center';
                            ctx.fillText('CLICK', pos.x, pos.y + radius + 18);
                        }
                    }
                }

                // Label for spell type
                if (spell && spell !== 'dud') {
                    const isManaShards = nodeName === manaShardsNodeName;
                    const isCharging = isManaShards && manaShardsState === 'charging';
                    const isCharged = isManaShards && manaShardsState === 'charged';

                    // Special label styling for charging/charged Mana Shards
                    if (isCharged) {
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 12px Georgia';
                    } else if (isCharging) {
                        ctx.fillStyle = '#00ffff';
                        ctx.font = 'bold 11px Georgia';
                    } else {
                        ctx.fillStyle = state === 'active' ? '#fff' : hexToRgba('#fff', 0.4);
                        ctx.font = state === 'active' ? 'bold 10px Georgia' : '9px Georgia';
                    }
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    // Special label for Mana Shards, otherwise first letter
                    const label = spell === MANA_SHARDS ? '' : spell.charAt(0).toUpperCase();
                    ctx.fillText(label, pos.x, pos.y);
                }
            });

            // Draw awareness indicator (pulsing white ring)
            const awPulse = Math.sin(animationTime * 6) * 0.3 + 0.7;
            const currentRadius = awarenessAtNode ? getNodeRadius(awarenessAtNode) : nodeNetwork.pathwayRadius;
            const awSize = currentRadius + 6 + Math.sin(animationTime * 4) * 3;

            // Outer glow
            const awGlow = ctx.createRadialGradient(
                awarenessPos.x, awarenessPos.y, awSize - 4,
                awarenessPos.x, awarenessPos.y, awSize + 12
            );
            awGlow.addColorStop(0, `rgba(255, 255, 255, ${awPulse * 0.5})`);
            awGlow.addColorStop(0.5, `rgba(200, 220, 255, ${awPulse * 0.3})`);
            awGlow.addColorStop(1, 'rgba(200, 220, 255, 0)');
            ctx.fillStyle = awGlow;
            ctx.beginPath();
            ctx.arc(awarenessPos.x, awarenessPos.y, awSize + 12, 0, Math.PI * 2);
            ctx.fill();

            // Bright ring
            ctx.strokeStyle = `rgba(255, 255, 255, ${awPulse})`;
            ctx.lineWidth = 3;
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(awarenessPos.x, awarenessPos.y, awSize, 0, Math.PI * 2);
            ctx.stroke();

            // Inner ring
            ctx.strokeStyle = `rgba(200, 230, 255, ${awPulse * 0.8})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(awarenessPos.x, awarenessPos.y, awSize - 4, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText('BODY NODES', cx, cy - 135);

            ctx.restore();
        }

        // Get enemy node world position
        function getEnemyNodePosition(nodeName) {
            const nodeInfo = enemyNodeNetwork.nodes[nodeName];
            if (!nodeInfo) return { x: 0, y: 0 };

            return {
                x: enemyNodeNetwork.centerX + nodeInfo.x * enemyNodeNetwork.scale,
                y: enemyNodeNetwork.centerY + nodeInfo.y * enemyNodeNetwork.scale
            };
        }

        // Get enemy node radius based on type
        function getEnemyNodeRadius(nodeName) {
            const nodeInfo = enemyNodeNetwork.nodes[nodeName];
            if (!nodeInfo) return enemyNodeNetwork.pathwayRadius;

            return nodeInfo.type === NODE_TYPE_FUNCTIONAL
                ? enemyNodeNetwork.functionalRadius
                : enemyNodeNetwork.pathwayRadius;
        }

        // Get color for enemy node based on its spell assignment
        function getEnemyNodeColor(nodeName) {
            const nodeInfo = enemyNodeNetwork.nodes[nodeName];
            if (!nodeInfo) return '#666666';

            // Pathway nodes are always grey
            if (nodeInfo.type === NODE_TYPE_PATHWAY) return '#555555';

            // Functional nodes get spell color or dud grey
            const spell = enemyNodeNetwork.spellAssignments[nodeName];
            if (spell === 'dud') return '#666666';
            return colors[spell] || '#666666';
        }

        // Check if a point is over an enemy node (for targeting)
        function getEnemyNodeAtPosition(x, y) {
            // Check all enemy nodes (both functional and pathway)
            for (const nodeName of enemyNodeNames) {
                const pos = getEnemyNodePosition(nodeName);
                const radius = getEnemyNodeRadius(nodeName);
                const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                // Slightly larger hit area for easier targeting
                if (dist <= radius + 5) {
                    return nodeName;
                }
            }
            return null;
        }

        // Check if we're in targeting mode (Mana Shards charged)
        function isInTargetingMode() {
            return manaShardsState === 'charged';
        }

        // Draw targeting mode UI indicator
        function drawTargetingModeUI() {
            if (!isInTargetingMode()) return;

            // Pulsing "SELECT TARGET" text at top center
            const pulse = Math.sin(animationTime * 4) * 0.2 + 0.8;

            // Background banner
            ctx.fillStyle = `rgba(80, 20, 20, ${pulse * 0.8})`;
            ctx.beginPath();
            ctx.roundRect(canvas.width / 2 - 120, 70, 240, 35, 6);
            ctx.fill();

            // Border
            ctx.strokeStyle = `rgba(255, 100, 100, ${pulse})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(canvas.width / 2 - 120, 70, 240, 35, 6);
            ctx.stroke();

            // Text
            ctx.font = 'bold 18px Georgia';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = `rgba(255, 200, 200, ${pulse})`;
            ctx.shadowColor = '#ff4444';
            ctx.shadowBlur = 10;
            ctx.fillText(' SELECT TARGET ', canvas.width / 2, 88);
            ctx.shadowBlur = 0;

            // Crosshair icon near enemy node network
            const cx = enemyNodeNetwork.centerX;
            const cy = enemyNodeNetwork.centerY - 165;
            const crossSize = 12 + Math.sin(animationTime * 6) * 2;

            ctx.strokeStyle = `rgba(255, 100, 100, ${pulse})`;
            ctx.lineWidth = 2;
            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(cx - crossSize, cy);
            ctx.lineTo(cx + crossSize, cy);
            ctx.stroke();
            // Vertical line
            ctx.beginPath();
            ctx.moveTo(cx, cy - crossSize);
            ctx.lineTo(cx, cy + crossSize);
            ctx.stroke();
            // Circle
            ctx.beginPath();
            ctx.arc(cx, cy, crossSize * 0.7, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Fire a Mana Shards projectile at an enemy node
        function fireManaShardProjectile(targetNodeName) {
            const startPos = getNodePosition(manaShardsNodeName);
            const endPos = getEnemyNodePosition(targetNodeName);

            manaShardProjectile = {
                startX: startPos.x,
                startY: startPos.y,
                endX: endPos.x,
                endY: endPos.y,
                currentX: startPos.x,
                currentY: startPos.y,
                targetNode: targetNodeName,
                startTime: performance.now(),
                progress: 0
            };

            // Reset Mana Shards state immediately after firing
            manaShardsState = 'idle';
            manaShardsChargeProgress = 0;
            hoveredEnemyNode = null;
            canvas.style.cursor = 'default';

            console.log(`[MANA SHARDS] Projectile fired at: ${targetNodeName}`);
        }

        // Update and draw the Mana Shards projectile
        function updateAndDrawManaShardProjectile(timestamp) {
            if (!manaShardProjectile) return;

            const elapsed = timestamp - manaShardProjectile.startTime;
            const progress = Math.min(1, elapsed / projectileTravelTime);

            // Easing function for smooth acceleration/deceleration
            const easeProgress = progress < 0.5
                ? 2 * progress * progress
                : 1 - Math.pow(-2 * progress + 2, 2) / 2;

            // Update position
            manaShardProjectile.currentX = manaShardProjectile.startX +
                (manaShardProjectile.endX - manaShardProjectile.startX) * easeProgress;
            manaShardProjectile.currentY = manaShardProjectile.startY +
                (manaShardProjectile.endY - manaShardProjectile.startY) * easeProgress;
            manaShardProjectile.progress = progress;

            // Spawn trail particles
            if (Math.random() < 0.6) {
                projectileTrailParticles.push({
                    x: manaShardProjectile.currentX + (Math.random() - 0.5) * 8,
                    y: manaShardProjectile.currentY + (Math.random() - 0.5) * 8,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    life: 1,
                    decay: 0.04 + Math.random() * 0.03,
                    size: 3 + Math.random() * 4
                });
            }

            // Draw trail particles
            ctx.save();
            for (let i = projectileTrailParticles.length - 1; i >= 0; i--) {
                const p = projectileTrailParticles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay;

                if (p.life <= 0) {
                    projectileTrailParticles.splice(i, 1);
                    continue;
                }

                // Cyan/ice blue gradient
                const alpha = p.life * 0.8;
                ctx.beginPath();
                ctx.fillStyle = `rgba(100, 220, 255, ${alpha})`;
                ctx.shadowColor = '#66ddff';
                ctx.shadowBlur = 8;
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            ctx.restore();

            // Draw main projectile
            const px = manaShardProjectile.currentX;
            const py = manaShardProjectile.currentY;
            const pulseSize = 12 + Math.sin(timestamp * 0.02) * 3;

            // Outer glow
            const glowGradient = ctx.createRadialGradient(px, py, 0, px, py, pulseSize + 15);
            glowGradient.addColorStop(0, 'rgba(100, 220, 255, 0.8)');
            glowGradient.addColorStop(0.4, 'rgba(80, 200, 255, 0.4)');
            glowGradient.addColorStop(0.7, 'rgba(60, 180, 255, 0.15)');
            glowGradient.addColorStop(1, 'rgba(60, 180, 255, 0)');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(px, py, pulseSize + 15, 0, Math.PI * 2);
            ctx.fill();

            // Inner core
            ctx.fillStyle = '#aaeeff';
            ctx.shadowColor = '#66ddff';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(px, py, pulseSize * 0.6, 0, Math.PI * 2);
            ctx.fill();

            // Bright center
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(px, py, pulseSize * 0.25, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Check for arrival
            if (progress >= 1) {
                createManaShardImpact(manaShardProjectile.endX, manaShardProjectile.endY, manaShardProjectile.targetNode);
                manaShardProjectile = null;
            }
        }

        // Create impact effect when projectile hits
        function createManaShardImpact(x, y, targetNodeName) {
            // Create explosion particles (red-tinted for damage)
            const particleCount = 40;
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.3;
                const speed = 4 + Math.random() * 8;
                // Mix of cyan and red particles for damage effect
                const color = Math.random() > 0.4 ? '#66ddff' : '#ff6666';
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 4 + Math.random() * 6,
                    color: color
                });
            }

            // Add some white core particles
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    decay: 0.03 + Math.random() * 0.03,
                    size: 3 + Math.random() * 3,
                    color: '#ffffff'
                });
            }

            // Create custom impact flash at the hit location
            manaShardImpactFlash = {
                x: x,
                y: y,
                intensity: 1.0,
                startTime: performance.now()
            };

            // === DAMAGE EFFECTS ===

            // Reduce enemy HP by 3
            enemyHP = Math.max(0, enemyHP - 3);
            console.log(`[MANA SHARDS] Impact! Enemy HP: ${enemyHP}/${MAX_HP}`);

            // Mark the node as damaged (if not already)
            if (!enemyNodeDamaged[targetNodeName]) {
                enemyNodeDamaged[targetNodeName] = true;
                console.log(`[MANA SHARDS] Node DAMAGED: ${targetNodeName}`);

                // If it's a functional node that was active, recalculate mana
                // Active node was +1, damaged active node is -1, so net change is -2
                const nodeInfo = enemyNodeNetwork.nodes[targetNodeName];
                if (nodeInfo && nodeInfo.type === NODE_TYPE_FUNCTIONAL) {
                    if (enemyNodeStates[targetNodeName] === 'active') {
                        enemyActiveMana = enemyActiveMana - 2; // Was +1, now -1
                        console.log(`[MANA SHARDS] Enemy mana reduced! Now: ${enemyActiveMana}`);
                    }

                    // Check if enemy's current beam type is still available
                    // If not, force them to switch to an available beam
                    if (enemyBeamType && !isEnemyBeamTypeAvailable(enemyBeamType)) {
                        console.log(`[MANA SHARDS] Enemy beam type ${enemyBeamType} no longer available! Forcing switch.`);
                        enemyBeamType = pickStrategicBeam();
                        enemyBeamSwitchTime = performance.now() + 500;
                    }
                }
            }
        }

        // Update and draw the Mana Shard impact flash
        function updateAndDrawManaShardImpactFlash() {
            if (!manaShardImpactFlash) return;

            // Fade out over 300ms
            const elapsed = performance.now() - manaShardImpactFlash.startTime;
            const duration = 300;
            manaShardImpactFlash.intensity = Math.max(0, 1 - elapsed / duration);

            if (manaShardImpactFlash.intensity <= 0) {
                manaShardImpactFlash = null;
                return;
            }

            const x = manaShardImpactFlash.x;
            const y = manaShardImpactFlash.y;
            const intensity = manaShardImpactFlash.intensity;

            ctx.save();

            // Expanding ring
            const ringSize = 60 * (1 - intensity) + 20;
            ctx.strokeStyle = `rgba(100, 220, 255, ${intensity * 0.8})`;
            ctx.lineWidth = 4 * intensity;
            ctx.shadowColor = '#66ddff';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(x, y, ringSize, 0, Math.PI * 2);
            ctx.stroke();

            // Second ring
            const ring2Size = 40 * (1 - intensity) + 10;
            ctx.strokeStyle = `rgba(200, 240, 255, ${intensity * 0.6})`;
            ctx.lineWidth = 3 * intensity;
            ctx.beginPath();
            ctx.arc(x, y, ring2Size, 0, Math.PI * 2);
            ctx.stroke();

            // Central flash
            const flashGradient = ctx.createRadialGradient(x, y, 0, x, y, 40 * intensity);
            flashGradient.addColorStop(0, `rgba(255, 255, 255, ${intensity * 0.9})`);
            flashGradient.addColorStop(0.3, `rgba(150, 230, 255, ${intensity * 0.6})`);
            flashGradient.addColorStop(0.7, `rgba(80, 200, 255, ${intensity * 0.2})`);
            flashGradient.addColorStop(1, 'rgba(60, 180, 255, 0)');
            ctx.fillStyle = flashGradient;
            ctx.beginPath();
            ctx.arc(x, y, 40 * intensity, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // Draw the enemy node network (display only - mirrored on right side)
        function drawEnemyNodeNetwork() {
            // Position below enemy wizard (right side)
            enemyNodeNetwork.centerX = canvas.width - 160;
            enemyNodeNetwork.centerY = canvas.height - 185;

            const cx = enemyNodeNetwork.centerX;
            const cy = enemyNodeNetwork.centerY;

            ctx.save();

            // Draw background panel
            ctx.fillStyle = 'rgba(40, 20, 40, 0.7)';  // Slightly purple tint for enemy
            ctx.strokeStyle = 'rgba(150, 100, 150, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(cx - 140, cy - 150, 280, 310, 10);
            ctx.fill();
            ctx.stroke();

            // Draw all connections (edges between nodes)
            ctx.strokeStyle = 'rgba(120, 100, 120, 0.6)';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            const drawnEdges = new Set();
            for (const nodeName of enemyNodeNames) {
                const nodePos = getEnemyNodePosition(nodeName);
                const neighbors = enemyNodeNetwork.connections[nodeName] || [];

                for (const neighbor of neighbors) {
                    // Avoid drawing same edge twice
                    const edgeKey = [nodeName, neighbor].sort().join('-');
                    if (drawnEdges.has(edgeKey)) continue;
                    drawnEdges.add(edgeKey);

                    const neighborPos = getEnemyNodePosition(neighbor);
                    ctx.beginPath();
                    ctx.moveTo(nodePos.x, nodePos.y);
                    ctx.lineTo(neighborPos.x, neighborPos.y);
                    ctx.stroke();
                }
            }

            // Draw pathway nodes (small grey dots)
            enemyPathwayNodeNames.forEach(nodeName => {
                const pos = getEnemyNodePosition(nodeName);
                const radius = getEnemyNodeRadius(nodeName);
                const isHovered = isInTargetingMode() && hoveredEnemyNode === nodeName;
                const isTargetable = isInTargetingMode();
                const isDamaged = enemyNodeDamaged[nodeName];
                const isRepairing = enemyNodeRepairing[nodeName];
                const repairProg = enemyNodeRepairProgress[nodeName] || 0;

                // Targeting highlight - outer glow when hovered
                if (isHovered) {
                    ctx.fillStyle = 'rgba(255, 100, 100, 0.4)';
                    ctx.shadowColor = '#ff4444';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius + 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                // Damaged nodes: dark red/maroon color (or blue if repairing)
                // Normal nodes: grey (brighter when targetable)
                if (isRepairing) {
                    ctx.fillStyle = 'rgba(60, 80, 100, 0.9)';
                } else if (isDamaged) {
                    ctx.fillStyle = 'rgba(80, 30, 30, 0.9)';
                } else {
                    ctx.fillStyle = isTargetable ? 'rgba(140, 120, 140, 0.9)' : 'rgba(100, 80, 100, 0.8)';
                }
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Outline - red pulsing when hovered, brighter when targetable
                if (isHovered) {
                    const pulse = Math.sin(animationTime * 8) * 0.3 + 0.7;
                    ctx.strokeStyle = `rgba(255, 100, 100, ${pulse})`;
                    ctx.lineWidth = 3;
                } else if (isRepairing) {
                    ctx.strokeStyle = 'rgba(100, 150, 200, 0.8)';
                    ctx.lineWidth = 2;
                } else if (isDamaged) {
                    ctx.strokeStyle = 'rgba(180, 50, 50, 0.8)';
                    ctx.lineWidth = 2;
                } else if (isTargetable) {
                    ctx.strokeStyle = 'rgba(255, 150, 150, 0.6)';
                    ctx.lineWidth = 2;
                } else {
                    ctx.strokeStyle = 'rgba(140, 120, 140, 0.6)';
                    ctx.lineWidth = 1;
                }
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Draw X overlay for damaged pathway nodes (not when repairing)
                if (isDamaged && !isRepairing) {
                    ctx.strokeStyle = 'rgba(255, 80, 80, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(pos.x - radius * 0.6, pos.y - radius * 0.6);
                    ctx.lineTo(pos.x + radius * 0.6, pos.y + radius * 0.6);
                    ctx.moveTo(pos.x + radius * 0.6, pos.y - radius * 0.6);
                    ctx.lineTo(pos.x - radius * 0.6, pos.y + radius * 0.6);
                    ctx.stroke();
                }

                // Repair progress for pathway nodes
                if (isRepairing) {
                    const progressRadius = radius + 3;
                    const startAngle = -Math.PI / 2;
                    const endAngle = startAngle + (repairProg * Math.PI * 2);

                    ctx.strokeStyle = '#66aaff';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.shadowColor = '#66aaff';
                    ctx.shadowBlur = 6;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, progressRadius, startAngle, endAngle);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    ctx.lineCap = 'butt';
                }
            });

            // Draw functional nodes (larger, colored) - with all states
            enemyFunctionalNodeNames.forEach(nodeName => {
                const pos = getEnemyNodePosition(nodeName);
                const radius = getEnemyNodeRadius(nodeName);
                let color = getEnemyNodeColor(nodeName);
                const spell = enemyNodeNetwork.spellAssignments[nodeName];
                const state = enemyNodeStates[nodeName] || 'dormant';
                const activationProg = enemyNodeActivationProgress[nodeName] || 0;
                const isHovered = isInTargetingMode() && hoveredEnemyNode === nodeName;
                const isTargetable = isInTargetingMode();
                const isDamaged = enemyNodeDamaged[nodeName];
                const isRepairing = enemyNodeRepairing[nodeName];
                const repairProg = enemyNodeRepairProgress[nodeName] || 0;

                // Damaged nodes use a dark red color instead of their normal color
                if (isDamaged && !isRepairing) {
                    color = '#882222';
                } else if (isRepairing) {
                    color = '#446688'; // Blue-ish for repair
                }

                // Targeting highlight - outer glow when hovered (draw first, behind node)
                if (isHovered) {
                    ctx.fillStyle = 'rgba(255, 100, 100, 0.3)';
                    ctx.shadowColor = '#ff4444';
                    ctx.shadowBlur = 25;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius + 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                if (state === 'dormant') {
                    // DORMANT: dim, outline only
                    ctx.strokeStyle = hexToRgba(color, 0.4);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Very faint fill
                    ctx.fillStyle = hexToRgba(color, 0.1);
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.fill();

                } else if (state === 'activating') {
                    // ACTIVATING: dim node with circular progress bar
                    ctx.fillStyle = hexToRgba(color, 0.25);
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = hexToRgba(color, 0.5);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Progress bar
                    const progressRadius = radius + 5;
                    const startAngle = -Math.PI / 2;
                    const endAngle = startAngle + (activationProg * Math.PI * 2);

                    ctx.strokeStyle = hexToRgba(color, 0.2);
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, progressRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.strokeStyle = color;
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, progressRadius, startAngle, endAngle);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    ctx.lineCap = 'butt';

                } else if (state === 'active') {
                    // ACTIVE: bright, glowing
                    const glowSize = radius + 10 + Math.sin(animationTime * 4) * 2;
                    const glowGradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, glowSize);
                    glowGradient.addColorStop(0, hexToRgba(color, 0.8));
                    glowGradient.addColorStop(0.4, hexToRgba(color, 0.4));
                    glowGradient.addColorStop(0.7, hexToRgba(color, 0.15));
                    glowGradient.addColorStop(1, hexToRgba(color, 0));
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, glowSize, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = color;
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Label for spell type (hidden if damaged)
                if (spell && spell !== 'dud' && !isDamaged) {
                    ctx.fillStyle = state === 'active' ? '#fff' : hexToRgba('#fff', 0.4);
                    ctx.font = state === 'active' ? 'bold 10px Georgia' : '9px Georgia';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    // Special label for Mana Shards, otherwise first letter
                    const label = spell === MANA_SHARDS ? '' : spell.charAt(0).toUpperCase();
                    ctx.fillText(label, pos.x, pos.y);
                }

                // DAMAGE OVERLAY for damaged functional nodes
                if (isDamaged) {
                    if (isRepairing) {
                        // REPAIRING: show repair progress with blue/white theme
                        // Darker overlay during repair
                        ctx.fillStyle = 'rgba(40, 60, 80, 0.6)';
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                        ctx.fill();

                        // Repair progress bar (blue/cyan)
                        const progressRadius = radius + 5;
                        const startAngle = -Math.PI / 2;
                        const endAngle = startAngle + (repairProg * Math.PI * 2);

                        // Background ring
                        ctx.strokeStyle = 'rgba(100, 150, 200, 0.3)';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, progressRadius, 0, Math.PI * 2);
                        ctx.stroke();

                        // Progress ring (blue/cyan)
                        ctx.strokeStyle = '#66aaff';
                        ctx.lineWidth = 4;
                        ctx.lineCap = 'round';
                        ctx.shadowColor = '#66aaff';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, progressRadius, startAngle, endAngle);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        ctx.lineCap = 'butt';

                        // Wrench/repair icon (simple representation)
                        ctx.fillStyle = 'rgba(150, 200, 255, 0.9)';
                        ctx.font = 'bold 12px Georgia';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('', pos.x, pos.y); // Using lightning as "repair" icon
                    } else {
                        // NOT REPAIRING: show damage overlay
                        // Dark red overlay
                        ctx.fillStyle = 'rgba(100, 20, 20, 0.5)';
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                        ctx.fill();

                        // Red X mark
                        ctx.strokeStyle = 'rgba(255, 80, 80, 0.9)';
                        ctx.lineWidth = 3;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(pos.x - radius * 0.5, pos.y - radius * 0.5);
                        ctx.lineTo(pos.x + radius * 0.5, pos.y + radius * 0.5);
                        ctx.moveTo(pos.x + radius * 0.5, pos.y - radius * 0.5);
                        ctx.lineTo(pos.x - radius * 0.5, pos.y + radius * 0.5);
                        ctx.stroke();
                        ctx.lineCap = 'butt';

                        // Crack lines emanating from center
                        ctx.strokeStyle = 'rgba(60, 20, 20, 0.8)';
                        ctx.lineWidth = 1;
                        const crackAngles = [0.3, 1.2, 2.5, 3.8, 5.1];
                        crackAngles.forEach(angle => {
                            ctx.beginPath();
                            ctx.moveTo(pos.x, pos.y);
                            const len = radius * (0.6 + Math.random() * 0.4);
                            ctx.lineTo(pos.x + Math.cos(angle) * len, pos.y + Math.sin(angle) * len);
                            ctx.stroke();
                        });

                        // "-1" mana indicator for active damaged nodes
                        if (state === 'active') {
                            ctx.fillStyle = '#ff4444';
                            ctx.font = 'bold 10px Georgia';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('-1', pos.x, pos.y + radius + 12);
                        }
                    }
                }

                // Targeting overlay ring (drawn on top)
                if (isHovered) {
                    // Pulsing red targeting ring
                    const pulse = Math.sin(animationTime * 8) * 0.3 + 0.7;
                    ctx.strokeStyle = `rgba(255, 80, 80, ${pulse})`;
                    ctx.lineWidth = 4;
                    ctx.shadowColor = '#ff4444';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius + 4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                } else if (isTargetable) {
                    // Subtle red tint to show all nodes are targetable
                    ctx.strokeStyle = 'rgba(255, 120, 120, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius + 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            // Draw enemy awareness indicator (pulsing ring - slightly different color than player)
            const awPulse = Math.sin(animationTime * 6) * 0.3 + 0.7;
            const currentRadius = enemyAwarenessAtNode ? getEnemyNodeRadius(enemyAwarenessAtNode) : enemyNodeNetwork.pathwayRadius;
            const awSize = currentRadius + 6 + Math.sin(animationTime * 4) * 3;

            // Outer glow (purple tint for enemy)
            const awGlow = ctx.createRadialGradient(
                enemyAwarenessPos.x, enemyAwarenessPos.y, awSize - 4,
                enemyAwarenessPos.x, enemyAwarenessPos.y, awSize + 12
            );
            awGlow.addColorStop(0, `rgba(255, 200, 255, ${awPulse * 0.5})`);
            awGlow.addColorStop(0.5, `rgba(220, 180, 255, ${awPulse * 0.3})`);
            awGlow.addColorStop(1, 'rgba(220, 180, 255, 0)');
            ctx.fillStyle = awGlow;
            ctx.beginPath();
            ctx.arc(enemyAwarenessPos.x, enemyAwarenessPos.y, awSize + 12, 0, Math.PI * 2);
            ctx.fill();

            // Bright ring (purple tint)
            ctx.strokeStyle = `rgba(255, 200, 255, ${awPulse})`;
            ctx.lineWidth = 3;
            ctx.shadowColor = '#f0f';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(enemyAwarenessPos.x, enemyAwarenessPos.y, awSize, 0, Math.PI * 2);
            ctx.stroke();

            // Inner ring
            ctx.strokeStyle = `rgba(255, 220, 255, ${awPulse * 0.8})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(enemyAwarenessPos.x, enemyAwarenessPos.y, awSize - 4, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Title
            ctx.fillStyle = '#c9a';
            ctx.font = 'bold 14px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText('ENEMY NODES', cx, cy - 135);

            ctx.restore();
        }

        // Spell types
        const SUPPRESS = 'suppress';
        const SPIRAL = 'spiral';
        const PULSE = 'pulse';
        const ZAP = 'zap';
        const MANA_SHARDS = 'mana_shards';

        // Colors
        const colors = {
            suppress: '#95a5a6',
            spiral: '#9b59b6',
            pulse: '#e74c3c',
            zap: '#f1c40f',
            mana_shards: '#00d4ff'  // Cyan/ice blue
        };

        // Stability system
        let playerStability = 100;
        let enemyStability = 100;
        const STABILITY_DRAIN_RATE = 25;  // % per second while on Suppress (4 seconds to drain)
        const STABILITY_REGEN_RATE = 25;  // % per second while on attack beam (4 seconds to regen)

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Determine winner: returns 1 if a wins, -1 if b wins, 0 if tie
        function getClashResult(a, b) {
            if (a === b) return 0;
            if ((a === SPIRAL && b === ZAP) ||
                (a === ZAP && b === PULSE) ||
                (a === PULSE && b === SPIRAL)) {
                return 1;
            }
            return -1;
        }

        // Enemy AI - sticky random
        function pickNewEnemyBeam() {
            const choices = [SPIRAL, PULSE, ZAP];
            let newBeam;
            do {
                newBeam = choices[Math.floor(Math.random() * choices.length)];
            } while (newBeam === enemyCurrentBeam && enemyCurrentBeam !== null);

            enemyCurrentBeam = newBeam;
            enemyClashesRemaining = 3 + Math.floor(Math.random() * 2);
        }

        function getEnemyChoice() {
            if (enemyCurrentBeam === null || enemyClashesRemaining <= 0) {
                pickNewEnemyBeam();
            }
            return enemyCurrentBeam;
        }

        function showClashResult(text, color) {
            clashResult.textContent = text;
            clashResult.style.color = color;
            clashResult.style.opacity = 1;
            setTimeout(() => {
                clashResult.style.opacity = 0;
            }, 1000);
        }

        function clash() {
            if (!gameActive) return;

            const player = playerChoice || getEnemyChoice();
            const enemy = getEnemyChoice();

            const result = getClashResult(player, enemy);

            let resultText = '';
            let resultColor = 'white';

            if (result === 1) {
                ballPosition = Math.min(100, ballPosition + 10);
                resultText = `${player.toUpperCase()} beats ${enemy.toUpperCase()}! +10%`;
                resultColor = '#2ecc71';
            } else if (result === -1) {
                ballPosition = Math.max(0, ballPosition - 10);
                resultText = `${enemy.toUpperCase()} beats ${player.toUpperCase()}! -10%`;
                resultColor = '#e74c3c';
            } else {
                resultText = `Both chose ${player.toUpperCase()}! TIE`;
                resultColor = '#f1c40f';
            }

            showClashResult(resultText, resultColor);

            const { meterY, clashX } = getBeamPositions();
            clashFlashIntensity = 1;
            lastClashResult = result;
            createClashParticles(clashX, meterY, resultColor);

            enemyClashesRemaining--;

            if (ballPosition <= 0) {
                endGame(false);
            } else if (ballPosition >= 100) {
                endGame(true);
            }
        }

        function endGame(playerWon) {
            gameActive = false;
            gameOverScreen.style.display = 'flex';

            if (playerWon) {
                gameOverScreen.className = 'win';
                gameOverText.textContent = 'Enemy vaporized!';
            } else {
                gameOverScreen.className = 'lose';
                gameOverText.textContent = 'You were vaporized!';
            }
        }

        function restartGame() {
            ballPosition = 50;
            // playerChoice will be set by initBoostAndCooldowns() to center's beam type
            gameActive = true;
            lastClashTime = performance.now();
            gameOverScreen.style.display = 'none';
            enemyCurrentBeam = null;
            enemyClashesRemaining = 0;
            // Enemy AI state reset in initBoostAndCooldowns()
            particles = [];
            projectileTrailParticles = [];
            clashFlashIntensity = 0;
            manaShardProjectile = null;
            manaShardImpactFlash = null;
            // Reset HP
            playerHP = MAX_HP;
            enemyHP = MAX_HP;
            // Reset Stability
            playerStability = 100;
            enemyStability = 100;
            lastStabilityUpdate = 0;
            initStickFigureNodes();
            initEnemyNodeNetwork();
            initNodeStates();
            initStickAwareness();
            initEnemyAwareness();
            initBoostAndCooldowns();  // This calls switchEnemyBeam() which respects node activation
            updateButtonStates();
        }

        function updateButtonStates() {
            suppressBtn.style.outline = playerChoice === SUPPRESS ? '4px solid white' : 'none';
            spiralBtn.style.outline = playerChoice === SPIRAL ? '4px solid white' : 'none';
            pulseBtn.style.outline = playerChoice === PULSE ? '4px solid white' : 'none';
            zapBtn.style.outline = playerChoice === ZAP ? '4px solid white' : 'none';
        }

        function selectSpell(spell) {
            if (!gameActive) return;
            playerChoice = spell;
            updateButtonStates();
        }

        function activateBoost(spell) {
            if (!gameActive) return;

            const now = performance.now();

            // Special rule: Switching TO Neutral has NO cooldown (can always bail to safety)
            if (spell === SUPPRESS) {
                playerBeamType = SUPPRESS;
                playerChoice = SUPPRESS;
                // Clear all cooldowns when going to suppress
                cooldowns.suppress = 0;
                cooldowns.spiral = 0;
                cooldowns.pulse = 0;
                cooldowns.zap = 0;
                updateButtonStates();
                return;
            }

            // Check if this beam type is unlocked (has active node)
            if (!isBeamTypeUnlocked(spell)) return;

            // For attack types (Spiral/Pulse/Zap):
            // Check if ANY attack cooldown is active
            const attackCooldownActive = cooldowns.spiral > now || cooldowns.pulse > now || cooldowns.zap > now;
            if (attackCooldownActive) return;

            // Commit to this attack beam type
            playerBeamType = spell;

            // Put ALL attack buttons on cooldown (committed for 5 seconds)
            // Neutral never has cooldown
            cooldowns.suppress = 0;
            cooldowns.spiral = now + cooldownDuration;
            cooldowns.pulse = now + cooldownDuration;
            cooldowns.zap = now + cooldownDuration;

            // Also select this spell for visual
            playerChoice = spell;
            updateButtonStates();
        }

        function getEffectiveMana() {
            let effective = playerActiveMana;

            // Apply debuff if enemy is countering us
            const debuff = getPlayerManaDebuff();
            effective -= debuff;

            // Apply Mana Shards charging penalty (-1 mana while charging or charged)
            if (isManaShardsDrawingMana()) {
                effective -= 1;
            }

            // Floor at 0 (can't have negative effective mana)
            return Math.max(0, effective);
        }

        function getEffectiveEnemyMana() {
            let effective = enemyActiveMana;

            // Apply debuff if player is countering enemy
            const debuff = getEnemyManaDebuff();
            effective -= debuff;

            // Floor at 0 (can't have negative effective mana)
            return Math.max(0, effective);
        }

        // Check if a beam type has at least one active functional node
        function isBeamTypeUnlocked(beamType) {
            if (beamType === SUPPRESS) return true; // Neutral always unlocked

            for (const nodeName of functionalNodeNames) {
                const spell = nodeNetwork.spellAssignments[nodeName];
                const state = nodeStates[nodeName];
                if (spell === beamType && state === 'active') {
                    return true;
                }
            }
            return false;
        }

        function updateCooldownDisplay() {
            const now = performance.now();
            const maxRemaining = Math.max(
                cooldowns.spiral - now,
                cooldowns.pulse - now,
                cooldowns.zap - now
            );
            const attackOnCooldown = maxRemaining > 0;

            // Handle attack buttons (Spiral, Pulse, Zap)
            [SPIRAL, PULSE, ZAP].forEach(spell => {
                const btn = spell === SPIRAL ? spiralBtn : spell === PULSE ? pulseBtn : zapBtn;
                const isActive = playerBeamType === spell;
                const isUnlocked = isBeamTypeUnlocked(spell);

                if (!isUnlocked) {
                    // LOCKED - no active node for this beam type
                    btn.disabled = true;
                    btn.textContent = ` ${spell.toUpperCase()}`;
                    btn.style.opacity = '0.3';
                    btn.style.outline = 'none';
                    btn.style.filter = 'grayscale(80%)';
                    btn.title = `Activate a ${spell.charAt(0).toUpperCase() + spell.slice(1)} node first`;
                } else if (attackOnCooldown) {
                    // UNLOCKED but on cooldown
                    btn.disabled = true;
                    btn.style.filter = 'none';
                    btn.title = '';
                    if (isActive) {
                        btn.textContent = `${spell.toUpperCase()} (${(maxRemaining / 1000).toFixed(1)}s)`;
                        btn.style.opacity = '1';
                        btn.style.outline = '3px solid white';
                    } else {
                        btn.textContent = spell.toUpperCase();
                        btn.style.opacity = '0.5';
                        btn.style.outline = 'none';
                    }
                } else {
                    // UNLOCKED and available
                    btn.disabled = false;
                    btn.textContent = spell.toUpperCase();
                    btn.style.opacity = '1';
                    btn.style.filter = 'none';
                    btn.style.outline = isActive ? '3px solid white' : 'none';
                    btn.title = '';

                    // Check if just became unlocked (trigger animation)
                    if (!previousUnlockStates[spell]) {
                        btn.classList.add('unlocked');
                        setTimeout(() => btn.classList.remove('unlocked'), 500);
                    }
                }

                // Update previous state
                previousUnlockStates[spell] = isUnlocked;
            });

            // Neutral button is ALWAYS available (no cooldown to switch to it)
            const suppressActive = playerBeamType === SUPPRESS;
            suppressBtn.disabled = false;
            suppressBtn.textContent = 'SUPPRESS';
            suppressBtn.style.opacity = '1';
            suppressBtn.style.filter = 'none';
            suppressBtn.style.outline = suppressActive ? '3px solid white' : 'none';
            suppressBtn.title = '';
        }

        function initBoostAndCooldowns() {
            // Start with center node's beam type (center is always active at game start)
            const centerBeamType = nodeNetwork.spellAssignments['center'];
            playerBeamType = centerBeamType;
            playerChoice = centerBeamType;
            cooldowns = { suppress: 0, spiral: 0, pulse: 0, zap: 0 };

            // Enemy starts with their center node's beam type
            const enemyCenterBeamType = enemyNodeNetwork.spellAssignments['center'];
            enemyBeamType = enemyCenterBeamType;
            enemyLastPlayerBeam = playerBeamType;  // Initialize AI tracking
            enemySuppressStartTime = 0;
            enemyBeamSwitchTime = performance.now() + 500;  // Start AI decisions quickly
            console.log('[ENEMY AI] Starting with center beam:', enemyBeamType);

            updateCooldownDisplay();
        }

        // Check if enemy has at least one active, non-damaged node for a beam type
        function isEnemyBeamTypeAvailable(beamType) {
            if (beamType === SUPPRESS) return true; // Neutral always available

            for (const nodeName of enemyFunctionalNodeNames) {
                const spell = enemyNodeNetwork.spellAssignments[nodeName];
                const state = enemyNodeStates[nodeName];
                const isDamaged = enemyNodeDamaged[nodeName];
                // Must be active AND not damaged
                if (spell === beamType && state === 'active' && !isDamaged) {
                    return true;
                }
            }
            return false;
        }

        // Get the beam type that counters a given beam
        function getCounterBeam(beamType) {
            // PULSE beats SPIRAL, ZAP beats PULSE, SPIRAL beats ZAP
            if (beamType === SPIRAL) return PULSE;
            if (beamType === PULSE) return ZAP;
            if (beamType === ZAP) return SPIRAL;
            return null; // SUPPRESS has no counter
        }

        // Check if enemy is currently being countered by player
        function isEnemyBeingCountered() {
            if (!playerBeamType || !enemyBeamType) return false;
            if (playerBeamType === SUPPRESS || enemyBeamType === SUPPRESS) return false;
            return getCounterResult(playerBeamType, enemyBeamType) === 1;
        }

        // Strategic AI: pick optimal beam type
        function pickStrategicBeam() {
            const availableAttackBeams = [SPIRAL, PULSE, ZAP].filter(beam => isEnemyBeamTypeAvailable(beam));

            // If player is on Suppress, just use any available attack beam
            if (playerBeamType === SUPPRESS) {
                if (availableAttackBeams.length > 0) {
                    return availableAttackBeams[Math.floor(Math.random() * availableAttackBeams.length)];
                }
                return SUPPRESS;
            }

            // PRIMARY: Try to counter the player's beam
            const counterBeam = getCounterBeam(playerBeamType);
            if (counterBeam && isEnemyBeamTypeAvailable(counterBeam)) {
                console.log(`[ENEMY AI] Countering player's ${playerBeamType} with ${counterBeam}`);
                return counterBeam;
            }

            // FALLBACK: Pick any available attack beam that isn't countered by player
            const playerCounter = getCounterBeam(playerBeamType); // What player would counter
            const safeBeams = availableAttackBeams.filter(beam => {
                // Avoid beams that player counters
                return getCounterResult(playerBeamType, beam) !== 1;
            });

            if (safeBeams.length > 0) {
                const pick = safeBeams[Math.floor(Math.random() * safeBeams.length)];
                console.log(`[ENEMY AI] No counter available, picking safe beam: ${pick}`);
                return pick;
            }

            // Last resort: any available attack beam
            if (availableAttackBeams.length > 0) {
                const pick = availableAttackBeams[Math.floor(Math.random() * availableAttackBeams.length)];
                console.log(`[ENEMY AI] No safe beams, picking: ${pick}`);
                return pick;
            }

            // No attack beams available at all
            console.log('[ENEMY AI] No attack beams available, using SUPPRESS');
            return SUPPRESS;
        }

        // Enemy AI decision timing
        const ENEMY_REACT_TIME = 300;        // React to player changes after 300ms
        const ENEMY_SUPPRESS_DURATION = 1200; // Stay on Suppress for 1-1.5 seconds
        let enemyLastPlayerBeam = null;
        let enemySuppressStartTime = 0;

        function updateEnemyBeam(timestamp) {
            // Check if enemy is being countered - might need to retreat to Suppress
            if (isEnemyBeingCountered() && enemyBeamType !== SUPPRESS) {
                // Switch to Suppress to escape counter
                console.log(`[ENEMY AI] Being countered! Retreating to SUPPRESS`);
                enemyBeamType = SUPPRESS;
                enemySuppressStartTime = timestamp;
                enemyBeamSwitchTime = timestamp + ENEMY_SUPPRESS_DURATION + Math.random() * 300;
                return;
            }

            // If on Suppress, check if we should switch back to attack
            if (enemyBeamType === SUPPRESS) {
                if (timestamp >= enemyBeamSwitchTime) {
                    const newBeam = pickStrategicBeam();
                    if (newBeam !== SUPPRESS) {
                        enemyBeamType = newBeam;
                        console.log(`[ENEMY AI] Leaving SUPPRESS, switching to ${newBeam}`);
                    }
                    enemyBeamSwitchTime = timestamp + ENEMY_REACT_TIME;
                }
                return;
            }

            // Detect if player changed beam type - react after short delay
            if (playerBeamType !== enemyLastPlayerBeam) {
                enemyLastPlayerBeam = playerBeamType;
                enemyBeamSwitchTime = timestamp + ENEMY_REACT_TIME;
                return;
            }

            // Time to make a decision
            if (timestamp >= enemyBeamSwitchTime) {
                const optimalBeam = pickStrategicBeam();

                // Only switch if it's better than current
                if (optimalBeam !== enemyBeamType && optimalBeam !== SUPPRESS) {
                    enemyBeamType = optimalBeam;
                    console.log(`[ENEMY AI] Switching to optimal beam: ${optimalBeam}`);
                }

                // Check again after a short delay
                enemyBeamSwitchTime = timestamp + 500 + Math.random() * 500;
            }
        }

        // Stability system - drain while on Suppress, regen while on attack beam
        let lastStabilityUpdate = 0;

        function updateStability(timestamp) {
            if (!gameActive) return;

            // Calculate delta time
            if (lastStabilityUpdate === 0) {
                lastStabilityUpdate = timestamp;
                return;
            }
            const deltaTime = (timestamp - lastStabilityUpdate) / 1000;
            lastStabilityUpdate = timestamp;

            // Player stability
            if (playerBeamType === SUPPRESS) {
                // Drain: 0% in 2 seconds = 50% per second
                playerStability -= STABILITY_DRAIN_RATE * deltaTime;
                if (playerStability <= 0) {
                    playerStability = 0;
                    triggerStabilityPunishment(true);
                }
            } else {
                // Regen: 100% in 4 seconds = 25% per second
                playerStability = Math.min(100, playerStability + STABILITY_REGEN_RATE * deltaTime);
            }

            // Enemy stability
            if (enemyBeamType === SUPPRESS) {
                enemyStability -= STABILITY_DRAIN_RATE * deltaTime;
                if (enemyStability <= 0) {
                    enemyStability = 0;
                    triggerStabilityPunishment(false);
                }
            } else {
                enemyStability = Math.min(100, enemyStability + STABILITY_REGEN_RATE * deltaTime);
            }
        }

        function triggerStabilityPunishment(isPlayer) {
            const nodeNames = isPlayer ? functionalNodeNames : enemyFunctionalNodeNames;
            const damagedMap = isPlayer ? nodeDamaged : enemyNodeDamaged;

            // Find all undamaged functional nodes
            const undamagedNodes = nodeNames.filter(name => !damagedMap[name]);

            if (undamagedNodes.length > 0) {
                // Pick a random undamaged node to damage
                const victimNode = undamagedNodes[Math.floor(Math.random() * undamagedNodes.length)];
                damagedMap[victimNode] = true;

                // If player, also update node state and mana
                if (isPlayer) {
                    if (nodeStates[victimNode] === 'active') {
                        playerActiveMana = Math.max(0, playerActiveMana - 1);
                    }
                    nodeStates[victimNode] = 'dormant';
                    nodeActivationProgress[victimNode] = 0;
                } else {
                    if (enemyNodeStates[victimNode] === 'active') {
                        enemyActiveMana = Math.max(0, enemyActiveMana - 1);
                    }
                    enemyNodeStates[victimNode] = 'dormant';
                    enemyNodeActivationProgress[victimNode] = 0;
                }

                console.log(`[STABILITY] ${isPlayer ? 'Player' : 'Enemy'} punished - damaged node: ${victimNode}`);
            }

            // Reset stability to 100% after punishment
            if (isPlayer) {
                playerStability = 100;
            } else {
                enemyStability = 100;
            }
        }

        suppressBtn.addEventListener('click', () => activateBoost(SUPPRESS));
        spiralBtn.addEventListener('click', () => activateBoost(SPIRAL));
        pulseBtn.addEventListener('click', () => activateBoost(PULSE));
        zapBtn.addEventListener('click', () => activateBoost(ZAP));
        restartBtn.addEventListener('click', restartGame);

        // Drawing functions
        function drawBackground() {
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, '#1a1a3a');
            gradient.addColorStop(1, '#0a0a1a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawWizard(x, y, isPlayer, color) {
            ctx.save();
            ctx.translate(x, y);

            ctx.fillStyle = isPlayer ? '#3498db' : '#9b59b6';
            ctx.beginPath();
            ctx.moveTo(0, -30);
            ctx.lineTo(-30, 50);
            ctx.lineTo(30, 50);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(0, -80);
            ctx.lineTo(-25, -30);
            ctx.lineTo(25, -30);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#fad7a0';
            ctx.beginPath();
            ctx.arc(0, -15, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(isPlayer ? 5 : -5, -18, 3, 0, Math.PI * 2);
            ctx.arc(isPlayer ? -5 : 5, -18, 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(isPlayer ? 35 : -35, -20);
            ctx.lineTo(isPlayer ? 50 : -50, 40);
            ctx.stroke();

            ctx.fillStyle = color || '#fff';
            ctx.shadowColor = color || '#fff';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(isPlayer ? 35 : -35, -25, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.restore();
        }

        function drawBeamMeter() {
            const { meterY, clashX } = getBeamPositions();

            const glowSize = 30 + Math.sin(animationTime * 5) * 5;

            const ballGradient = ctx.createRadialGradient(clashX, meterY, 0, clashX, meterY, glowSize);
            ballGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            ballGradient.addColorStop(0.3, 'rgba(100, 200, 255, 0.8)');
            ballGradient.addColorStop(0.6, 'rgba(100, 150, 255, 0.4)');
            ballGradient.addColorStop(1, 'rgba(100, 100, 255, 0)');

            ctx.fillStyle = ballGradient;
            ctx.beginPath();
            ctx.arc(clashX, meterY, glowSize, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(clashX, meterY, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function getBeamPositions() {
            const meterY = canvas.height / 2;
            const playerStartX = 135;
            const enemyStartX = canvas.width - 135;
            const beamLength = enemyStartX - playerStartX;
            const clashX = playerStartX + (ballPosition / 100) * beamLength;
            return { meterY, clashX, playerStartX, enemyStartX, beamLength };
        }

        function getClashProgress() {
            const now = performance.now();
            const elapsed = now - lastClashTime;
            return Math.min(1, elapsed / clashInterval);
        }

        function drawBaseEnergyBeam() {
            const { meterY, clashX, playerStartX, enemyStartX } = getBeamPositions();

            ctx.save();

            // Calculate beam thickness based on active mana
            const playerThickness = getBeamThickness(playerActiveMana);
            const enemyThickness = getBeamThickness(enemyActiveMana);

            const playerColor = colors[playerChoice];
            const playerGradient = ctx.createLinearGradient(playerStartX, 0, clashX, 0);
            const flowOffset = (animationTime * 0.5) % 1;

            for (let i = 0; i < 5; i++) {
                const pos = ((i / 5) + flowOffset) % 1;
                const alpha = 0.15 + Math.sin(pos * Math.PI) * 0.1;
                playerGradient.addColorStop(Math.min(0.99, Math.max(0.01, pos)), hexToRgba(playerColor, alpha));
            }

            ctx.strokeStyle = playerGradient;
            ctx.lineWidth = playerThickness;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(playerStartX, meterY);
            ctx.lineTo(clashX, meterY);
            ctx.stroke();

            const playerCoreGradient = ctx.createLinearGradient(playerStartX, 0, clashX, 0);
            playerCoreGradient.addColorStop(0, hexToRgba(playerColor, 0.4));
            playerCoreGradient.addColorStop(1, hexToRgba(playerColor, 0.2));
            ctx.strokeStyle = playerCoreGradient;
            ctx.lineWidth = playerThickness * 0.35;
            ctx.beginPath();
            ctx.moveTo(playerStartX, meterY);
            ctx.lineTo(clashX, meterY);
            ctx.stroke();

            const playerBeamLength = clashX - playerStartX;
            const playerParticleCount = Math.floor(4 + (playerActiveMana / 6) * 8); // More particles with more mana
            for (let i = 0; i < playerParticleCount; i++) {
                const particleT = ((i / playerParticleCount) + animationTime * 0.8) % 1;
                const px = playerStartX + particleT * playerBeamLength;
                const py = meterY + Math.sin(animationTime * 10 + i * 2) * (playerThickness * 0.25);
                const particleSize = (2 + Math.sin(animationTime * 8 + i) * 1) * (playerThickness / 12);
                const particleAlpha = 0.3 + Math.sin(particleT * Math.PI) * 0.4;

                ctx.fillStyle = hexToRgba(playerColor, particleAlpha);
                ctx.beginPath();
                ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                ctx.fill();
            }

            const enemyColor = colors[enemyBeamType] || '#9b59b6';
            const enemyGradient = ctx.createLinearGradient(enemyStartX, 0, clashX, 0);
            const enemyFlowOffset = (animationTime * 0.5) % 1;

            for (let i = 0; i < 5; i++) {
                const pos = ((i / 5) + enemyFlowOffset) % 1;
                const alpha = 0.15 + Math.sin(pos * Math.PI) * 0.1;
                enemyGradient.addColorStop(Math.min(0.99, Math.max(0.01, 1 - pos)), hexToRgba(enemyColor, alpha));
            }

            ctx.strokeStyle = enemyGradient;
            ctx.lineWidth = enemyThickness;
            ctx.beginPath();
            ctx.moveTo(enemyStartX, meterY);
            ctx.lineTo(clashX, meterY);
            ctx.stroke();

            const enemyCoreGradient = ctx.createLinearGradient(enemyStartX, 0, clashX, 0);
            enemyCoreGradient.addColorStop(0, hexToRgba(enemyColor, 0.4));
            enemyCoreGradient.addColorStop(1, hexToRgba(enemyColor, 0.2));
            ctx.strokeStyle = enemyCoreGradient;
            ctx.lineWidth = enemyThickness * 0.35;
            ctx.beginPath();
            ctx.moveTo(enemyStartX, meterY);
            ctx.lineTo(clashX, meterY);
            ctx.stroke();

            const enemyBeamLength = enemyStartX - clashX;
            const enemyParticleCount = Math.floor(4 + (enemyActiveMana / 6) * 8); // More particles with more mana
            for (let i = 0; i < enemyParticleCount; i++) {
                const particleT = ((i / enemyParticleCount) + animationTime * 0.8) % 1;
                const px = enemyStartX - particleT * enemyBeamLength;
                const py = meterY + Math.sin(animationTime * 10 + i * 2 + Math.PI) * (enemyThickness * 0.25);
                const particleSize = (2 + Math.sin(animationTime * 8 + i + Math.PI) * 1) * (enemyThickness / 12);
                const particleAlpha = 0.3 + Math.sin(particleT * Math.PI) * 0.4;

                ctx.fillStyle = hexToRgba(enemyColor, particleAlpha);
                ctx.beginPath();
                ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                ctx.fill();
            }

            const pulseSize = 15 + Math.sin(animationTime * 6) * 5;
            const clashGlow = ctx.createRadialGradient(clashX, meterY, 0, clashX, meterY, pulseSize);
            clashGlow.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            clashGlow.addColorStop(0.5, 'rgba(255, 255, 255, 0.15)');
            clashGlow.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = clashGlow;
            ctx.beginPath();
            ctx.arc(clashX, meterY, pulseSize, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // SPIRAL BEAM
        function drawSpiralBeam(startX, endX, y, color, isPlayer, thickness = 12) {
            const progress = getClashProgress();
            const length = Math.abs(endX - startX);
            const thicknessScale = thickness / 12; // Scale factor relative to default

            ctx.save();

            const projectileX = isPlayer ?
                startX + progress * length :
                startX - progress * length;

            const traveledLength = Math.abs(projectileX - startX);
            const segments = Math.max(20, Math.floor(traveledLength / 5));
            const amplitude = 15 * thicknessScale;
            const frequency = 0.08;
            const rotationSpeed = 10;

            for (let spiral = 0; spiral < 2; spiral++) {
                const phaseOffset = spiral * Math.PI;
                ctx.beginPath();

                const spiralGradient = isPlayer ?
                    ctx.createLinearGradient(startX, 0, projectileX, 0) :
                    ctx.createLinearGradient(startX, 0, projectileX, 0);
                spiralGradient.addColorStop(0, hexToRgba(color, 0.3));
                spiralGradient.addColorStop(0.7, hexToRgba(color, 0.6));
                spiralGradient.addColorStop(1, hexToRgba(color, 0.8));

                ctx.strokeStyle = spiralGradient;
                ctx.lineWidth = (3 - spiral) * thicknessScale;

                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const x = isPlayer ?
                        startX + t * traveledLength :
                        startX - t * traveledLength;

                    const waveOffset = Math.sin(t * traveledLength * frequency + animationTime * rotationSpeed + phaseOffset) * amplitude;

                    if (i === 0) {
                        ctx.moveTo(x, y + waveOffset);
                    } else {
                        ctx.lineTo(x, y + waveOffset);
                    }
                }
                ctx.stroke();
            }

            const particleCount = Math.floor(4 + thicknessScale * 4);
            for (let i = 0; i < particleCount; i++) {
                const t = (i / particleCount + animationTime * 0.5) % 1;
                const px = isPlayer ?
                    startX + t * traveledLength :
                    startX - t * traveledLength;
                const py = y + Math.sin(t * traveledLength * frequency + animationTime * rotationSpeed) * amplitude;

                ctx.fillStyle = hexToRgba(color, 0.6);
                ctx.beginPath();
                ctx.arc(px, py, 3 * thicknessScale, 0, Math.PI * 2);
                ctx.fill();
            }

            const projectileSize = 20 * thicknessScale;
            const spiralArms = 3;
            const projRotation = animationTime * 15;

            const glowGradient = ctx.createRadialGradient(projectileX, y, 0, projectileX, y, projectileSize * 2);
            glowGradient.addColorStop(0, hexToRgba(color, 0.7));
            glowGradient.addColorStop(0.5, hexToRgba(color, 0.3));
            glowGradient.addColorStop(1, hexToRgba(color, 0));
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(projectileX, y, projectileSize * 2, 0, Math.PI * 2);
            ctx.fill();

            for (let arm = 0; arm < spiralArms; arm++) {
                const armAngle = (Math.PI * 2 * arm) / spiralArms + projRotation;
                ctx.strokeStyle = hexToRgba(color, 0.9);
                ctx.lineWidth = 3 * thicknessScale;
                ctx.beginPath();

                for (let i = 0; i <= 12; i++) {
                    const t = i / 12;
                    const radius = t * projectileSize;
                    const angle = armAngle + t * Math.PI * 2;
                    const px = projectileX + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;

                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();
            }

            ctx.fillStyle = '#fff';
            ctx.shadowColor = color;
            ctx.shadowBlur = 15 * thicknessScale;
            ctx.beginPath();
            ctx.arc(projectileX, y, 7 * thicknessScale, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // ZAP BEAM
        function drawZapBeam(startX, endX, y, color, isPlayer, thickness = 12) {
            const progress = getClashProgress();
            const length = Math.abs(endX - startX);
            const thicknessScale = thickness / 12; // Scale factor relative to default

            ctx.save();

            const projectileX = isPlayer ?
                startX + progress * length :
                startX - progress * length;

            const traveledLength = Math.abs(projectileX - startX);
            const segments = Math.max(15, Math.floor(traveledLength / 8));

            ctx.shadowColor = color;
            ctx.shadowBlur = 10 * thicknessScale;

            const boltGradient = isPlayer ?
                ctx.createLinearGradient(startX, 0, projectileX, 0) :
                ctx.createLinearGradient(startX, 0, projectileX, 0);
            boltGradient.addColorStop(0, hexToRgba(color, 0.4));
            boltGradient.addColorStop(0.5, hexToRgba(color, 0.7));
            boltGradient.addColorStop(1, hexToRgba(color, 0.9));

            ctx.beginPath();
            ctx.strokeStyle = boltGradient;
            ctx.lineWidth = 3 * thicknessScale;

            ctx.moveTo(startX, y);

            for (let i = 1; i <= segments; i++) {
                const t = i / segments;
                const x = isPlayer ?
                    startX + t * traveledLength :
                    startX - t * traveledLength;
                const jitter = (Math.sin(i * 2.7 + animationTime * 35) * 18 +
                              Math.sin(i * 5.3 + animationTime * 55) * 10) * thicknessScale;
                ctx.lineTo(x, y + jitter);
            }
            ctx.stroke();

            ctx.beginPath();
            ctx.strokeStyle = hexToRgba(color, 0.5);
            ctx.lineWidth = 2 * thicknessScale;
            ctx.moveTo(startX, y);

            for (let i = 1; i <= segments; i++) {
                const t = i / segments;
                const x = isPlayer ?
                    startX + t * traveledLength :
                    startX - t * traveledLength;
                const jitter = (Math.cos(i * 3.1 + animationTime * 45) * 22 +
                              Math.sin(i * 6.7 + animationTime * 65) * 12) * thicknessScale;
                ctx.lineTo(x, y + jitter);
            }
            ctx.stroke();

            const sparkCount = Math.floor(6 + thicknessScale * 6);
            for (let i = 0; i < sparkCount; i++) {
                const t = (i / sparkCount + animationTime * 0.3) % 1;
                const sparkX = isPlayer ?
                    startX + t * traveledLength :
                    startX - t * traveledLength;
                const sparkY = y + Math.sin(t * 50 + animationTime * 40 + i * 7) * 20 * thicknessScale;
                const sparkSize = (2 + Math.sin(animationTime * 30 + i * 5) * 1.5) * thicknessScale;

                ctx.fillStyle = hexToRgba(color, 0.7);
                ctx.beginPath();
                ctx.arc(sparkX, sparkY, Math.max(1, sparkSize), 0, Math.PI * 2);
                ctx.fill();
            }

            const projectileSize = 18 * thicknessScale;

            const glowGradient = ctx.createRadialGradient(projectileX, y, 0, projectileX, y, projectileSize * 2.5);
            glowGradient.addColorStop(0, hexToRgba(color, 0.8));
            glowGradient.addColorStop(0.4, hexToRgba(color, 0.4));
            glowGradient.addColorStop(1, hexToRgba(color, 0));
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(projectileX, y, projectileSize * 2.5, 0, Math.PI * 2);
            ctx.fill();

            const boltCount = 8;
            for (let i = 0; i < boltCount; i++) {
                const baseAngle = (Math.PI * 2 * i) / boltCount;
                const angle = baseAngle + Math.sin(animationTime * 25 + i * 4) * 0.4;
                const boltLength = (25 + Math.sin(animationTime * 35 + i * 3) * 12) * thicknessScale;

                ctx.strokeStyle = hexToRgba(color, 0.85);
                ctx.lineWidth = 2 * thicknessScale;
                ctx.beginPath();
                ctx.moveTo(projectileX, y);

                let bx = projectileX;
                let by = y;
                for (let j = 1; j <= 4; j++) {
                    const dist = (boltLength / 4) * j;
                    const jitter = Math.sin(animationTime * 50 + i * 10 + j * 5) * 6 * thicknessScale;
                    bx = projectileX + Math.cos(angle) * dist + Math.cos(angle + Math.PI/2) * jitter;
                    by = y + Math.sin(angle) * dist + Math.sin(angle + Math.PI/2) * jitter;
                    ctx.lineTo(bx, by);
                }
                ctx.stroke();
            }

            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 25 * thicknessScale;
            ctx.beginPath();
            ctx.arc(projectileX, y, 9 * thicknessScale, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ffffaa';
            ctx.beginPath();
            ctx.arc(projectileX, y, 5 * thicknessScale, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // PULSE BEAM
        function drawPulseBeam(startX, endX, y, color, isPlayer, thickness = 12) {
            const progress = getClashProgress();
            const length = endX - startX;
            const thicknessScale = thickness / 12; // Scale factor relative to default

            ctx.save();

            const orbX = isPlayer ?
                startX + progress * length :
                startX - progress * Math.abs(length);

            const trailLength = 50 * thicknessScale;
            const trailStartX = isPlayer ?
                Math.max(startX, orbX - trailLength) :
                Math.min(startX, orbX + trailLength);

            const orbTrailGradient = ctx.createLinearGradient(trailStartX, 0, orbX, 0);
            orbTrailGradient.addColorStop(0, hexToRgba(color, 0));
            orbTrailGradient.addColorStop(1, hexToRgba(color, 0.6));
            ctx.strokeStyle = orbTrailGradient;
            ctx.lineWidth = 8 * thicknessScale;
            ctx.beginPath();
            ctx.moveTo(trailStartX, y);
            ctx.lineTo(orbX, y);
            ctx.stroke();

            const orbSize = (15 + Math.sin(animationTime * 10) * 3) * thicknessScale;

            const glowGradient = ctx.createRadialGradient(orbX, y, 0, orbX, y, orbSize * 2);
            glowGradient.addColorStop(0, hexToRgba(color, 0.8));
            glowGradient.addColorStop(0.5, hexToRgba(color, 0.3));
            glowGradient.addColorStop(1, hexToRgba(color, 0));
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(orbX, y, orbSize * 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.shadowColor = color;
            ctx.shadowBlur = 20 * thicknessScale;
            ctx.beginPath();
            ctx.arc(orbX, y, orbSize * 0.6, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // SUPPRESS BEAM - simple, no special effects
        function drawNeutralBeam(startX, endX, y, color, isPlayer, thickness = 12) {
            const progress = getClashProgress();
            const length = Math.abs(endX - startX);
            const thicknessScale = thickness / 12;

            ctx.save();

            const projectileX = isPlayer ?
                startX + progress * length :
                startX - progress * length;

            const traveledLength = Math.abs(projectileX - startX);

            // Simple straight beam - no fancy effects
            const beamGradient = isPlayer ?
                ctx.createLinearGradient(startX, 0, projectileX, 0) :
                ctx.createLinearGradient(startX, 0, projectileX, 0);
            beamGradient.addColorStop(0, hexToRgba(color, 0.3));
            beamGradient.addColorStop(0.5, hexToRgba(color, 0.5));
            beamGradient.addColorStop(1, hexToRgba(color, 0.7));

            ctx.strokeStyle = beamGradient;
            ctx.lineWidth = 4 * thicknessScale;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(startX, y);
            ctx.lineTo(projectileX, y);
            ctx.stroke();

            // Simple core line
            ctx.strokeStyle = hexToRgba('#ffffff', 0.4);
            ctx.lineWidth = 2 * thicknessScale;
            ctx.beginPath();
            ctx.moveTo(startX, y);
            ctx.lineTo(projectileX, y);
            ctx.stroke();

            // Simple projectile - just a soft glow
            const projectileSize = 12 * thicknessScale;

            const glowGradient = ctx.createRadialGradient(projectileX, y, 0, projectileX, y, projectileSize * 1.5);
            glowGradient.addColorStop(0, hexToRgba(color, 0.6));
            glowGradient.addColorStop(0.5, hexToRgba(color, 0.3));
            glowGradient.addColorStop(1, hexToRgba(color, 0));
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(projectileX, y, projectileSize * 1.5, 0, Math.PI * 2);
            ctx.fill();

            // White center
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(projectileX, y, projectileSize * 0.4, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawBeamByType(beamType, startX, endX, y, color, isPlayer, thickness = 12) {
            switch (beamType) {
                case SUPPRESS:
                    drawNeutralBeam(startX, endX, y, color, isPlayer, thickness);
                    break;
                case SPIRAL:
                    drawSpiralBeam(startX, endX, y, color, isPlayer, thickness);
                    break;
                case ZAP:
                    drawZapBeam(startX, endX, y, color, isPlayer, thickness);
                    break;
                case PULSE:
                    drawPulseBeam(startX, endX, y, color, isPlayer, thickness);
                    break;
                default:
                    drawNeutralBeam(startX, endX, y, color, isPlayer, thickness);
            }
        }

        function drawBeams() {
            const { meterY, clashX, playerStartX, enemyStartX } = getBeamPositions();

            // Calculate beam thickness based on active mana
            const playerThickness = getBeamThickness(playerActiveMana);
            const enemyThickness = getBeamThickness(enemyActiveMana);

            const playerColor = colors[playerChoice];
            drawBeamByType(playerChoice, playerStartX, clashX, meterY, playerColor, true, playerThickness);

            const enemyColor = colors[enemyBeamType] || '#9b59b6';
            if (enemyBeamType) {
                drawBeamByType(enemyBeamType, enemyStartX, clashX, meterY, enemyColor, false, enemyThickness);
            }
        }

        function createClashParticles(x, y, resultColor) {
            const particleCount = 30;
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
                const speed = 3 + Math.random() * 5;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 3 + Math.random() * 4,
                    color: resultColor
                });
            }
        }

        function updateAndDrawParticles() {
            ctx.save();
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1;
                p.life -= p.decay;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }

                ctx.beginPath();
                ctx.fillStyle = hexToRgba(p.color, p.life);
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 10;
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function drawClashFlash() {
            if (clashFlashIntensity > 0) {
                const { meterY, clashX } = getBeamPositions();

                ctx.save();

                let flashColor = '#ffffff';
                if (lastClashResult === 1) flashColor = '#2ecc71';
                else if (lastClashResult === -1) flashColor = '#e74c3c';
                else flashColor = '#f1c40f';

                const ringSize = 80 * (1 - clashFlashIntensity) + 20;
                const ringOpacity = clashFlashIntensity * 0.6;
                ctx.strokeStyle = hexToRgba(flashColor, ringOpacity);
                ctx.lineWidth = 4 * clashFlashIntensity;
                ctx.beginPath();
                ctx.arc(clashX, meterY, ringSize, 0, Math.PI * 2);
                ctx.stroke();

                const ring2Size = 60 * (1 - clashFlashIntensity) + 10;
                ctx.strokeStyle = hexToRgba(flashColor, ringOpacity * 0.7);
                ctx.lineWidth = 3 * clashFlashIntensity;
                ctx.beginPath();
                ctx.arc(clashX, meterY, ring2Size, 0, Math.PI * 2);
                ctx.stroke();

                const coreSize = 40 * clashFlashIntensity;
                const coreGradient = ctx.createRadialGradient(clashX, meterY, 0, clashX, meterY, coreSize);
                coreGradient.addColorStop(0, hexToRgba('#ffffff', clashFlashIntensity * 0.9));
                coreGradient.addColorStop(0.3, hexToRgba(flashColor, clashFlashIntensity * 0.7));
                coreGradient.addColorStop(0.7, hexToRgba(flashColor, clashFlashIntensity * 0.3));
                coreGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(clashX, meterY, coreSize, 0, Math.PI * 2);
                ctx.fill();

                const spikeCount = 8;
                for (let i = 0; i < spikeCount; i++) {
                    const angle = (Math.PI * 2 * i) / spikeCount;
                    const spikeLength = 50 * clashFlashIntensity;
                    const startDist = 15;

                    ctx.strokeStyle = hexToRgba(flashColor, clashFlashIntensity * 0.8);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(
                        clashX + Math.cos(angle) * startDist,
                        meterY + Math.sin(angle) * startDist
                    );
                    ctx.lineTo(
                        clashX + Math.cos(angle) * (startDist + spikeLength),
                        meterY + Math.sin(angle) * (startDist + spikeLength)
                    );
                    ctx.stroke();
                }

                clashFlashIntensity -= 0.04;
                if (clashFlashIntensity < 0) clashFlashIntensity = 0;

                ctx.restore();
            }
        }

        function drawTimer() {
            if (!gameActive) return;

            const manaDiff = getEffectiveMana() - getEffectiveEnemyMana();
            const playerDebuff = getPlayerManaDebuff();
            const enemyDebuff = getEnemyManaDebuff();

            ctx.font = '20px Georgia';
            ctx.textAlign = 'center';

            // Show push status
            let statusText = '';
            let statusColor = '#f1c40f';
            if (manaDiff > 0) {
                statusText = `Pushing! (+${manaDiff} advantage)`;
                statusColor = '#2ecc71';
            } else if (manaDiff < 0) {
                statusText = `Being pushed! (${manaDiff} deficit)`;
                statusColor = '#e74c3c';
            } else {
                statusText = 'Deadlock';
                statusColor = '#f1c40f';
            }

            ctx.fillStyle = statusColor;
            ctx.shadowColor = statusColor;
            ctx.shadowBlur = 10;
            ctx.fillText(statusText, canvas.width / 2, 80);
            ctx.shadowBlur = 0;

            // Show beam matchup in center
            ctx.font = '16px Georgia';
            if (playerBeamType && enemyBeamType) {
                const playerColor = colors[playerBeamType];
                const enemyColor = colors[enemyBeamType];

                // Player beam
                ctx.textAlign = 'right';
                ctx.fillStyle = playerColor;
                ctx.fillText(playerBeamType.toUpperCase(), canvas.width / 2 - 30, 60);

                // VS
                ctx.textAlign = 'center';
                ctx.fillStyle = '#fff';
                ctx.fillText('vs', canvas.width / 2, 60);

                // Enemy beam
                ctx.textAlign = 'left';
                ctx.fillStyle = enemyColor;
                ctx.fillText(enemyBeamType.toUpperCase(), canvas.width / 2 + 30, 60);
            } else if (!playerBeamType) {
                ctx.fillStyle = '#888';
                ctx.fillText('Select a beam type to engage!', canvas.width / 2, 60);
            }
        }

        function drawTitle() {
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 28px Georgia';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10;
            ctx.fillText('WIZARD BEAMS', canvas.width / 2, 40);
            ctx.shadowBlur = 0;
        }

        function drawActiveMana() {
            const effectiveMana = getEffectiveMana();
            const effectiveEnemyMana = getEffectiveEnemyMana();
            const playerDebuff = getPlayerManaDebuff();
            const enemyDebuff = getEnemyManaDebuff();
            const isCountering = enemyDebuff > 0;
            const isCountered = playerDebuff > 0;

            // Player active mana (left side)
            ctx.textAlign = 'left';
            ctx.font = 'bold 16px Georgia';

            // Background box for player
            let boxColor = 'rgba(20, 20, 40, 0.8)';
            let borderColor = 'rgba(100, 150, 255, 0.5)';
            if (isCountering) {
                boxColor = 'rgba(30, 60, 30, 0.9)';
                borderColor = 'rgba(100, 255, 100, 0.8)';
            } else if (isCountered) {
                boxColor = 'rgba(60, 30, 30, 0.9)';
                borderColor = 'rgba(255, 100, 100, 0.8)';
            }
            ctx.fillStyle = boxColor;
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = playerBeamType ? 3 : 2;
            ctx.beginPath();
            ctx.roundRect(20, 100, 200, 65, 8);
            ctx.fill();
            ctx.stroke();

            // Player beam type indicator
            if (playerBeamType) {
                const beamColor = colors[playerBeamType];
                ctx.fillStyle = beamColor;
                ctx.shadowColor = beamColor;
                ctx.shadowBlur = 10;
                ctx.fillText(`Beam: ${playerBeamType.toUpperCase()}`, 32, 118);
                ctx.shadowBlur = 0;
            } else {
                ctx.fillStyle = '#888';
                ctx.fillText('Beam: NONE', 32, 118);
            }

            // Player mana with debuff if being countered or charging Mana Shards
            ctx.font = 'bold 14px Georgia';
            let manaText = `Mana: ${playerActiveMana}`;
            let manaColor = '#3498db';
            const isChargingShards = isManaShardsDrawingMana();

            if (playerDebuff > 0 && isChargingShards) {
                // Both countered AND charging shards
                manaText += ` -${playerDebuff} -1 = ${effectiveMana}`;
                manaColor = '#e74c3c';
            } else if (playerDebuff > 0) {
                // Just countered
                manaText += ` -${playerDebuff} = ${effectiveMana}`;
                manaColor = '#e74c3c';
            } else if (isChargingShards) {
                // Just charging shards
                manaText += ` -1 = ${effectiveMana}`;
                manaColor = '#66aaff'; // Cyan/blue for charging
            }
            ctx.fillStyle = manaColor;
            ctx.shadowColor = manaColor;
            ctx.shadowBlur = 8;
            ctx.fillText(manaText, 32, 138);
            ctx.shadowBlur = 0;

            // Counter status
            ctx.font = '12px Georgia';
            if (isCountering) {
                const debuffText = enemyDebuff === 6 ? '-6 (MAX!)' : '-3';
                ctx.fillStyle = '#2ecc71';
                ctx.fillText(`COUNTERING! (Enemy ${debuffText})`, 32, 155);
            } else if (isCountered) {
                const debuffText = playerDebuff === 6 ? '-6 (MAX!)' : '-3';
                ctx.fillStyle = '#e74c3c';
                ctx.fillText(`COUNTERED! (You ${debuffText})`, 32, 155);
            } else if (isChargingShards) {
                ctx.fillStyle = '#66aaff';
                const state = manaShardsState === 'charged' ? 'READY!' : 'CHARGING...';
                ctx.fillText(` MANA SHARDS ${state} (-1)`, 32, 155);
            } else if (playerBeamType && enemyBeamType) {
                ctx.fillStyle = '#f1c40f';
                ctx.fillText('EVEN MATCHUP', 32, 155);
            }

            // Enemy active mana (right side)
            ctx.textAlign = 'right';
            ctx.font = 'bold 16px Georgia';

            // Background box for enemy - highlight if being countered
            let enemyBoxColor = 'rgba(20, 20, 40, 0.8)';
            let enemyBorderColor = enemyBeamType ? colors[enemyBeamType] : 'rgba(155, 89, 182, 0.5)';
            if (isCountering) {
                enemyBoxColor = 'rgba(60, 30, 30, 0.9)';
                enemyBorderColor = 'rgba(255, 100, 100, 0.8)';
            }
            ctx.fillStyle = enemyBoxColor;
            ctx.strokeStyle = enemyBorderColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(canvas.width - 220, 100, 200, 65, 8);
            ctx.fill();
            ctx.stroke();

            // Enemy beam type indicator
            if (enemyBeamType) {
                const beamColor = colors[enemyBeamType];
                ctx.fillStyle = beamColor;
                ctx.shadowColor = beamColor;
                ctx.shadowBlur = 10;
                ctx.fillText(`Beam: ${enemyBeamType.toUpperCase()}`, canvas.width - 32, 118);
                ctx.shadowBlur = 0;
            }

            // Enemy mana with debuff if being countered
            ctx.font = 'bold 14px Georgia';
            let enemyManaText = `Mana: ${enemyActiveMana}`;
            let enemyManaColor = '#9b59b6';
            if (enemyDebuff > 0) {
                enemyManaText += ` -${enemyDebuff} = ${effectiveEnemyMana}`;
                enemyManaColor = '#e74c3c';
            }
            ctx.fillStyle = enemyManaColor;
            ctx.shadowColor = enemyManaColor;
            ctx.shadowBlur = 8;
            ctx.fillText(enemyManaText, canvas.width - 32, 138);
            ctx.shadowBlur = 0;

            // Show what beats enemy's beam
            ctx.font = '11px Georgia';
            ctx.fillStyle = '#888';
            if (enemyBeamType) {
                let counter = '';
                if (enemyBeamType === SUPPRESS) counter = 'N/A (Suppress)';
                else if (enemyBeamType === SPIRAL) counter = 'PULSE';
                else if (enemyBeamType === PULSE) counter = 'ZAP';
                else if (enemyBeamType === ZAP) counter = 'SPIRAL';
                ctx.fillText(`Counter with: ${counter}`, canvas.width - 32, 155);
            }

            // DEBUG: Show beam sync status
            ctx.textAlign = 'center';
            ctx.font = '10px monospace';
            ctx.fillStyle = '#666';
            ctx.fillText('DEBUG: Beam Sync Check', canvas.width / 2, canvas.height - 20);
            const visualBeam = enemyBeamType ? enemyBeamType.toUpperCase() : 'NONE';
            const calcBeam = enemyBeamType ? enemyBeamType.toUpperCase() : 'NONE';
            const syncStatus = visualBeam === calcBeam ? ' SYNCED' : ' MISMATCH';
            const syncColor = visualBeam === calcBeam ? '#2ecc71' : '#e74c3c';
            ctx.fillStyle = syncColor;
            ctx.fillText(`Visual: ${visualBeam} | Calc: ${calcBeam} | ${syncStatus}`, canvas.width / 2, canvas.height - 6);
        }

        function drawHP() {
            const pipWidth = 10;
            const pipHeight = 8;
            const pipGap = 2;
            const pipsPerRow = 15;
            const rowGap = 3;

            // Calculate pip color based on HP percentage
            function getPipColor(currentHP, maxHP) {
                const percent = currentHP / maxHP;
                if (percent > 0.5) return '#2ecc71';      // Green - healthy
                if (percent > 0.33) return '#f1c40f';     // Yellow - wounded
                return '#e74c3c';                          // Red - critical
            }

            // Draw HP pips for a wizard
            function drawHPPips(x, y, currentHP, maxHP, alignRight = false) {
                const totalWidth = pipsPerRow * (pipWidth + pipGap) - pipGap;
                const startX = alignRight ? x - totalWidth : x;
                const pipColor = getPipColor(currentHP, maxHP);

                for (let i = 0; i < maxHP; i++) {
                    const row = Math.floor(i / pipsPerRow);
                    const col = i % pipsPerRow;
                    const pipX = startX + col * (pipWidth + pipGap);
                    const pipY = y + row * (pipHeight + rowGap);

                    // Draw pip background (empty/lost HP)
                    ctx.fillStyle = 'rgba(40, 40, 60, 0.8)';
                    ctx.fillRect(pipX, pipY, pipWidth, pipHeight);

                    // Draw pip border
                    ctx.strokeStyle = 'rgba(80, 80, 100, 0.6)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(pipX, pipY, pipWidth, pipHeight);

                    // Draw filled pip if HP remains
                    if (i < currentHP) {
                        ctx.fillStyle = pipColor;
                        ctx.shadowColor = pipColor;
                        ctx.shadowBlur = 4;
                        ctx.fillRect(pipX + 1, pipY + 1, pipWidth - 2, pipHeight - 2);
                        ctx.shadowBlur = 0;
                    }
                }
            }

            // Player HP (left side, below mana box)
            ctx.font = 'bold 12px Georgia';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#aaa';
            ctx.fillText('HP:', 20, 185);
            drawHPPips(45, 175, playerHP, MAX_HP, false);

            // Enemy HP (right side, below mana box)
            ctx.textAlign = 'right';
            ctx.fillStyle = '#aaa';
            ctx.fillText('HP:', canvas.width - 185, 185);
            drawHPPips(canvas.width - 20, 175, enemyHP, MAX_HP, true);
        }

        function drawStability() {
            const barWidth = 150;
            const barHeight = 12;
            const yPos = 205;

            // Get stability bar color based on value
            function getStabilityColor(stability) {
                if (stability > 50) return '#2ecc71';      // Green - stable
                if (stability > 25) return '#f1c40f';      // Yellow - warning
                return '#e74c3c';                           // Red - critical
            }

            // Draw a stability bar
            function drawStabilityBar(x, stability, alignRight = false) {
                const startX = alignRight ? x - barWidth : x;
                const fillWidth = (stability / 100) * barWidth;
                const barColor = getStabilityColor(stability);

                // Bar background
                ctx.fillStyle = 'rgba(40, 40, 60, 0.8)';
                ctx.fillRect(startX, yPos, barWidth, barHeight);

                // Bar border
                ctx.strokeStyle = 'rgba(80, 80, 100, 0.6)';
                ctx.lineWidth = 1;
                ctx.strokeRect(startX, yPos, barWidth, barHeight);

                // Filled portion
                if (stability > 0) {
                    ctx.fillStyle = barColor;
                    ctx.shadowColor = barColor;
                    ctx.shadowBlur = 4;
                    ctx.fillRect(startX + 1, yPos + 1, Math.max(0, fillWidth - 2), barHeight - 2);
                    ctx.shadowBlur = 0;
                }
            }

            // Player stability (left side)
            ctx.font = 'bold 12px Georgia';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#aaa';
            ctx.fillText('STABILITY:', 20, yPos + 10);
            drawStabilityBar(95, playerStability, false);

            // Percentage text
            ctx.font = '10px Georgia';
            ctx.fillStyle = getStabilityColor(playerStability);
            ctx.fillText(`${Math.round(playerStability)}%`, 95 + barWidth + 5, yPos + 10);

            // Enemy stability (right side)
            ctx.font = 'bold 12px Georgia';
            ctx.textAlign = 'right';
            ctx.fillStyle = '#aaa';
            ctx.fillText('STABILITY:', canvas.width - 95 - barWidth - 5, yPos + 10);
            drawStabilityBar(canvas.width - 95, enemyStability, true);

            // Enemy percentage text
            ctx.font = '10px Georgia';
            ctx.fillStyle = getStabilityColor(enemyStability);
            ctx.textAlign = 'left';
            ctx.fillText(`${Math.round(enemyStability)}%`, canvas.width - 95 + 5, yPos + 10);
        }

        canvas.addEventListener('click', (e) => {
            if (!gameActive) return;

            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Check if in targeting mode and clicking on enemy node
            if (isInTargetingMode()) {
                const targetedNode = getEnemyNodeAtPosition(clickX, clickY);
                if (targetedNode) {
                    // Fire the projectile at the target!
                    fireManaShardProjectile(targetedNode);
                    return;
                }
            }

            // Check for stick figure node clicks
            const clickedStickNode = getClickedStickNode(clickX, clickY);
            if (clickedStickNode) {
                // Check if clicking on Mana Shards node while awareness is there
                if (clickedStickNode === manaShardsNodeName &&
                    awarenessAtNode === manaShardsNodeName &&
                    nodeStates[manaShardsNodeName] === 'active') {

                    // Toggle charging state
                    if (manaShardsState === 'idle') {
                        // Start charging
                        manaShardsState = 'charging';
                        manaShardsChargeStartTime = performance.now();
                        manaShardsChargeProgress = 0;
                    } else if (manaShardsState === 'charging' || manaShardsState === 'charged') {
                        // Cancel charging - return to idle
                        manaShardsState = 'idle';
                        manaShardsChargeProgress = 0;
                    }
                } else {
                    // Normal behavior - move awareness to clicked node
                    moveStickAwarenessTo(clickedStickNode);
                }
            }
        });

        // Mousemove handler for targeting mode hover detection
        canvas.addEventListener('mousemove', (e) => {
            if (!gameActive) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Update hovered enemy node when in targeting mode
            if (isInTargetingMode()) {
                hoveredEnemyNode = getEnemyNodeAtPosition(mouseX, mouseY);
                // Change cursor when hovering over targetable node
                canvas.style.cursor = hoveredEnemyNode ? 'crosshair' : 'default';
            } else {
                hoveredEnemyNode = null;
                canvas.style.cursor = 'default';
            }
        });

        function gameLoop(timestamp) {
            animationTime = timestamp / 1000;

            updateStickAwareness(timestamp);
            updateNodeActivation(timestamp);
            updateManaShardsCharging(timestamp);
            updateCooldownDisplay();
            updateEnemyBeam(timestamp);
            updateStability(timestamp);

            // Enemy AI updates
            updateEnemyAwareness(timestamp);
            updateEnemyNodeActivation(timestamp);
            updateEnemyNodeRepair(timestamp);
            updateEnemyAI(timestamp);

            if (gameActive) {
                // Continuous tug-of-war based on active mana difference
                const manaDiff = getEffectiveMana() - getEffectiveEnemyMana();
                // Move 1% per second per mana difference
                const pushRate = 1.0; // percent per second per mana diff
                const deltaTime = 1 / 60; // approximate frame time
                const pushAmount = manaDiff * pushRate * deltaTime;

                ballPosition = Math.max(0, Math.min(100, ballPosition + pushAmount));

                // Check win/lose conditions
                if (ballPosition <= 0) {
                    endGame(false);
                } else if (ballPosition >= 100) {
                    endGame(true);
                }
            }

            drawBackground();
            drawBaseEnergyBeam();
            drawBeams();
            drawBeamMeter();
            drawStickFigure();
            drawEnemyNodeNetwork();
            drawWizard(100, canvas.height / 2, true, colors[playerChoice]);
            drawWizard(canvas.width - 100, canvas.height / 2, false, colors[enemyBeamType] || '#9b59b6');
            updateAndDrawParticles();
            updateAndDrawManaShardProjectile(timestamp);
            updateAndDrawManaShardImpactFlash();
            drawClashFlash();
            drawTimer();
            drawTitle();
            drawActiveMana();
            drawHP();
            drawStability();
            drawTargetingModeUI();

            requestAnimationFrame(gameLoop);
        }

        // Start game
        lastClashTime = performance.now();
        updateButtonStates();
        // Enemy AI uses strategic beam selection in updateEnemyBeam()
        initStickFigureNodes();
        initEnemyNodeNetwork();
        initNodeStates();
        initStickAwareness();
        initEnemyAwareness();
        initBoostAndCooldowns();  // This calls switchEnemyBeam() which respects node activation
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
