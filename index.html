<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wizard Beams</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a1a;
            font-family: 'Georgia', serif;
        }

        #gameCanvas {
            display: block;
        }

        #controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 15px;
            z-index: 10;
        }

        .spell-btn {
            padding: 20px 40px;
            font-size: 24px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .spell-btn:hover:not(:disabled) {
            transform: scale(1.1);
        }

        .spell-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #spiralBtn {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
            box-shadow: 0 0 20px rgba(155, 89, 182, 0.5);
        }

        #pulseBtn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
        }

        #zapBtn {
            background: linear-gradient(135deg, #f1c40f, #f39c12);
            color: #333;
            box-shadow: 0 0 20px rgba(241, 196, 15, 0.5);
        }

        #neutralBtn {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            color: white;
            box-shadow: 0 0 20px rgba(149, 165, 166, 0.5);
        }

        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
        }

        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 30px currentColor;
        }

        #gameOver.win h1 {
            color: #2ecc71;
        }

        #gameOver.lose h1 {
            color: #e74c3c;
        }

        #restartBtn {
            padding: 15px 40px;
            font-size: 24px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #restartBtn:hover {
            transform: scale(1.1);
        }

        #clashResult {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: white;
            text-shadow: 0 0 20px white;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 50;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="controls">
        <button id="neutralBtn" class="spell-btn">Neutral</button>
        <button id="spiralBtn" class="spell-btn">Spiral</button>
        <button id="pulseBtn" class="spell-btn">Pulse</button>
        <button id="zapBtn" class="spell-btn">Zap</button>
    </div>

    <div id="clashResult"></div>

    <div id="gameOver">
        <h1 id="gameOverText"></h1>
        <button id="restartBtn">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const neutralBtn = document.getElementById('neutralBtn');
        const spiralBtn = document.getElementById('spiralBtn');
        const pulseBtn = document.getElementById('pulseBtn');
        const zapBtn = document.getElementById('zapBtn');
        const gameOverScreen = document.getElementById('gameOver');
        const gameOverText = document.getElementById('gameOverText');
        const restartBtn = document.getElementById('restartBtn');
        const clashResult = document.getElementById('clashResult');

        // Game state
        let ballPosition = 50; // 0-100, starts at center
        let playerChoice = 'neutral'; // Start with Neutral as default (safe, no modifier)
        let lastClashTime = 0;
        let clashInterval = 2000; // 2 seconds
        let gameActive = true;
        let animationTime = 0;

        // Enemy AI state (sticky random)
        let enemyCurrentBeam = null;
        let enemyClashesRemaining = 0;

        // Collision effects
        let particles = [];
        let clashFlashIntensity = 0;
        let lastClashResult = 0; // -1, 0, or 1

        // ============================================
        // NODE NETWORK SYSTEM
        // ============================================

        // Node types
        const NODE_TYPE_FUNCTIONAL = 'functional'; // Can be activated (head, center, hands, feet)
        const NODE_TYPE_PATHWAY = 'pathway';       // Transit only (neck, shoulders, elbows, hips, knees)

        // All nodes in the network
        const nodeNetwork = {
            centerX: 0,
            centerY: 0,
            scale: 1.5,  // 50% larger
            functionalRadius: 21,  // Larger for functional nodes (14 * 1.5)
            pathwayRadius: 9,      // Smaller for pathway nodes (6 * 1.5)

            // Node definitions: position offsets and type
            nodes: {
                // Functional nodes (6) - can be activated
                head:       { x: 0, y: -85, type: NODE_TYPE_FUNCTIONAL },
                center:     { x: 0, y: -20, type: NODE_TYPE_FUNCTIONAL },
                leftHand:   { x: -75, y: -15, type: NODE_TYPE_FUNCTIONAL },
                rightHand:  { x: 75, y: -15, type: NODE_TYPE_FUNCTIONAL },
                leftFoot:   { x: -30, y: 85, type: NODE_TYPE_FUNCTIONAL },
                rightFoot:  { x: 30, y: 85, type: NODE_TYPE_FUNCTIONAL },

                // Pathway nodes (9) - transit only
                neck:           { x: 0, y: -60, type: NODE_TYPE_PATHWAY },
                leftShoulder:   { x: -25, y: -35, type: NODE_TYPE_PATHWAY },
                rightShoulder:  { x: 25, y: -35, type: NODE_TYPE_PATHWAY },
                leftElbow:      { x: -50, y: -25, type: NODE_TYPE_PATHWAY },
                rightElbow:     { x: 50, y: -25, type: NODE_TYPE_PATHWAY },
                leftHip:        { x: -15, y: 20, type: NODE_TYPE_PATHWAY },
                rightHip:       { x: 15, y: 20, type: NODE_TYPE_PATHWAY },
                leftKnee:       { x: -25, y: 55, type: NODE_TYPE_PATHWAY },
                rightKnee:      { x: 25, y: 55, type: NODE_TYPE_PATHWAY }
            },

            // Adjacency list - which nodes connect to which
            connections: {
                // Head path
                head: ['neck'],
                neck: ['head', 'center'],

                // Center connects to neck and all limb starts
                center: ['neck', 'leftShoulder', 'rightShoulder', 'leftHip', 'rightHip'],

                // Left arm path
                leftShoulder: ['center', 'leftElbow'],
                leftElbow: ['leftShoulder', 'leftHand'],
                leftHand: ['leftElbow'],

                // Right arm path
                rightShoulder: ['center', 'rightElbow'],
                rightElbow: ['rightShoulder', 'rightHand'],
                rightHand: ['rightElbow'],

                // Left leg path
                leftHip: ['center', 'leftKnee'],
                leftKnee: ['leftHip', 'leftFoot'],
                leftFoot: ['leftKnee'],

                // Right leg path
                rightHip: ['center', 'rightKnee'],
                rightKnee: ['rightHip', 'rightFoot'],
                rightFoot: ['rightKnee']
            },

            // Spell assignments for functional nodes
            spellAssignments: {}
        };

        // List of all node names
        const allNodeNames = Object.keys(nodeNetwork.nodes);
        const functionalNodeNames = allNodeNames.filter(n => nodeNetwork.nodes[n].type === NODE_TYPE_FUNCTIONAL);
        const pathwayNodeNames = allNodeNames.filter(n => nodeNetwork.nodes[n].type === NODE_TYPE_PATHWAY);

        // Awareness state - now includes path following
        let awarenessPos = { x: 0, y: 0 };
        let awarenessAtNode = 'center';
        let awarenessPath = [];           // Array of nodes to traverse
        let awarenessPathIndex = 0;       // Current position in path
        let awarenessMoving = false;
        let awarenessMoveStartTime = 0;
        let awarenessMoveStartPos = { x: 0, y: 0 };
        let awarenessCurrentTarget = null; // Current immediate target node
        const awarenessStepTime = 300;    // Time to move between adjacent nodes (faster!)

        // Node activation state (only for functional nodes)
        // States: 'dormant', 'activating', 'active'
        let nodeStates = {};
        let nodeActivationProgress = {};
        let nodeActivationStartTime = {};
        const nodeActivationTime = 2000; // 2 seconds to activate

        // Active mana counters
        let playerActiveMana = 0;
        const enemyActiveMana = 3; // Fixed value for now

        // Beam type commitment system
        let playerBeamType = null; // Currently committed beam type
        let enemyBeamType = null; // Enemy's current beam type
        let enemyBeamSwitchTime = 0; // When enemy will switch beams
        const enemyBeamDuration = 4000 + Math.random() * 4000; // 4-8 seconds between switches
        const counterBonus = 3; // +3 or -3 based on counter

        // Cooldown system
        let cooldowns = {
            neutral: 0,
            spiral: 0,
            pulse: 0,
            zap: 0
        };
        const cooldownDuration = 5000; // 5 seconds commitment

        // Beam thickness based on mana (0-6 mana maps to min-max thickness)
        const BEAM_THICKNESS_MIN = 8;
        const BEAM_THICKNESS_MAX = 45;

        function getBeamThickness(mana) {
            // Clamp mana to 0-6 range
            const clampedMana = Math.max(0, Math.min(6, mana));
            // Linear interpolation from min to max
            return BEAM_THICKNESS_MIN + (clampedMana / 6) * (BEAM_THICKNESS_MAX - BEAM_THICKNESS_MIN);
        }

        // Rock-paper-scissors: returns 1 if a beats b, -1 if b beats a, 0 if tie/neutral
        function getCounterResult(a, b) {
            // Neutral always gives 0 modifier (no bonus, no penalty)
            if (a === NEUTRAL || b === NEUTRAL) return 0;
            if (a === b) return 0;
            if ((a === SPIRAL && b === ZAP) ||
                (a === ZAP && b === PULSE) ||
                (a === PULSE && b === SPIRAL)) {
                return 1; // a beats b
            }
            return -1; // b beats a
        }

        // Get counter modifier for player
        function getCounterModifier() {
            if (!playerBeamType || !enemyBeamType) return 0;
            const result = getCounterResult(playerBeamType, enemyBeamType);
            return result * counterBonus; // +3 if countering, -3 if countered, 0 if tie
        }

        // ============================================
        // PATHFINDING (BFS for shortest path)
        // ============================================

        function findPath(startNode, endNode) {
            if (startNode === endNode) return [startNode];
            if (!startNode || !endNode) return [];

            const visited = new Set();
            const queue = [[startNode]];
            visited.add(startNode);

            while (queue.length > 0) {
                const path = queue.shift();
                const currentNode = path[path.length - 1];

                const neighbors = nodeNetwork.connections[currentNode] || [];
                for (const neighbor of neighbors) {
                    if (neighbor === endNode) {
                        return [...path, neighbor];
                    }
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push([...path, neighbor]);
                    }
                }
            }

            return []; // No path found
        }

        // ============================================
        // NODE STATE FUNCTIONS
        // ============================================

        // Initialize node states (only functional nodes can be activated)
        function initNodeStates() {
            nodeStates = {};
            nodeActivationProgress = {};
            nodeActivationStartTime = {};
            playerActiveMana = 0;

            functionalNodeNames.forEach(name => {
                nodeStates[name] = 'dormant';
                nodeActivationProgress[name] = 0;
            });
        }

        // Start activating a node (only for functional nodes)
        function startNodeActivation(nodeName) {
            // Only functional nodes can be activated
            if (nodeNetwork.nodes[nodeName]?.type !== NODE_TYPE_FUNCTIONAL) return;

            if (nodeStates[nodeName] === 'dormant') {
                nodeStates[nodeName] = 'activating';
                nodeActivationStartTime[nodeName] = performance.now();
                nodeActivationProgress[nodeName] = 0;
            }
        }

        // Update node activation progress (call each frame)
        function updateNodeActivation(timestamp) {
            functionalNodeNames.forEach(nodeName => {
                if (nodeStates[nodeName] === 'activating') {
                    // Only progress if awareness is at this node
                    if (awarenessAtNode === nodeName) {
                        const elapsed = timestamp - nodeActivationStartTime[nodeName];
                        nodeActivationProgress[nodeName] = Math.min(1, elapsed / nodeActivationTime);

                        if (nodeActivationProgress[nodeName] >= 1) {
                            nodeStates[nodeName] = 'active';
                            playerActiveMana = Math.min(6, playerActiveMana + 1);
                        }
                    }
                }
            });
        }

        // Initialize spell assignments for functional nodes
        function initStickFigureNodes() {
            const spells = [SPIRAL, PULSE, ZAP];

            // Shuffle functional node names
            const shuffledNodes = [...functionalNodeNames].sort(() => Math.random() - 0.5);

            // First 3 get spells, rest are duds
            nodeNetwork.spellAssignments = {};
            shuffledNodes.forEach((nodeName, index) => {
                if (index < 3) {
                    nodeNetwork.spellAssignments[nodeName] = spells[index];
                } else {
                    nodeNetwork.spellAssignments[nodeName] = 'dud';
                }
            });
        }

        // Get color for a node based on its spell assignment
        function getNodeColor(nodeName) {
            const nodeInfo = nodeNetwork.nodes[nodeName];
            if (!nodeInfo) return '#666666';

            // Pathway nodes are always grey
            if (nodeInfo.type === NODE_TYPE_PATHWAY) return '#555555';

            // Functional nodes get spell color or dud grey
            const spell = nodeNetwork.spellAssignments[nodeName];
            if (spell === 'dud') return '#666666';
            return colors[spell] || '#666666';
        }

        // Get node world position
        function getNodePosition(nodeName) {
            const nodeInfo = nodeNetwork.nodes[nodeName];
            if (!nodeInfo) return { x: 0, y: 0 };

            return {
                x: nodeNetwork.centerX + nodeInfo.x * nodeNetwork.scale,
                y: nodeNetwork.centerY + nodeInfo.y * nodeNetwork.scale
            };
        }

        // Get node radius based on type
        function getNodeRadius(nodeName) {
            const nodeInfo = nodeNetwork.nodes[nodeName];
            if (!nodeInfo) return nodeNetwork.pathwayRadius;

            return nodeInfo.type === NODE_TYPE_FUNCTIONAL
                ? nodeNetwork.functionalRadius
                : nodeNetwork.pathwayRadius;
        }

        // ============================================
        // AWARENESS MOVEMENT (PATH-BASED)
        // ============================================

        // Initialize awareness at center node
        function initStickAwareness() {
            awarenessAtNode = 'center';
            awarenessPath = [];
            awarenessPathIndex = 0;
            awarenessMoving = false;
            awarenessCurrentTarget = null;
            // Start activating the center node since awareness begins there
            startNodeActivation('center');
        }

        // Update awareness position (follows path step by step)
        function updateStickAwareness(timestamp) {
            // Update network center position
            // Position below player wizard (left side)
            nodeNetwork.centerX = 160;
            nodeNetwork.centerY = canvas.height - 185;

            if (awarenessMoving && awarenessPath.length > 0) {
                const elapsed = timestamp - awarenessMoveStartTime;
                const progress = Math.min(1, elapsed / awarenessStepTime);
                // Ease out for smooth movement
                const eased = 1 - Math.pow(1 - progress, 2);

                const targetPos = getNodePosition(awarenessCurrentTarget);
                awarenessPos.x = awarenessMoveStartPos.x + (targetPos.x - awarenessMoveStartPos.x) * eased;
                awarenessPos.y = awarenessMoveStartPos.y + (targetPos.y - awarenessMoveStartPos.y) * eased;

                if (progress >= 1) {
                    // Arrived at current target node
                    awarenessAtNode = awarenessCurrentTarget;
                    awarenessPos = { ...targetPos };
                    awarenessPathIndex++;

                    // Check if there are more nodes in the path
                    if (awarenessPathIndex < awarenessPath.length) {
                        // Move to next node in path
                        awarenessCurrentTarget = awarenessPath[awarenessPathIndex];
                        awarenessMoveStartTime = timestamp;
                        awarenessMoveStartPos = { ...awarenessPos };
                    } else {
                        // Reached final destination
                        awarenessMoving = false;
                        awarenessPath = [];
                        awarenessPathIndex = 0;
                        awarenessCurrentTarget = null;

                        // Start activating if it's a functional node
                        startNodeActivation(awarenessAtNode);
                    }
                }
            } else if (!awarenessMoving && awarenessAtNode) {
                // Snap to current node position (in case canvas resized)
                const currentPos = getNodePosition(awarenessAtNode);
                awarenessPos = { ...currentPos };
            }
        }

        // Move awareness to a target node (uses pathfinding)
        function moveStickAwarenessTo(targetNode) {
            if (awarenessMoving) return; // Can't interrupt current movement
            if (awarenessAtNode === targetNode) return; // Already there
            if (!awarenessAtNode) return; // No starting point

            // Find path from current node to target
            const path = findPath(awarenessAtNode, targetNode);
            if (path.length < 2) return; // No valid path or already there

            // Start following the path (skip first node since we're already there)
            awarenessPath = path.slice(1);
            awarenessPathIndex = 0;
            awarenessCurrentTarget = awarenessPath[0];
            awarenessMoving = true;
            awarenessMoveStartTime = performance.now();
            awarenessMoveStartPos = { ...awarenessPos };
            awarenessAtNode = null; // In transit
        }

        // Check if a click hit any node (functional nodes only for interaction)
        function getClickedStickNode(clickX, clickY) {
            // Only allow clicking on functional nodes
            for (const nodeName of functionalNodeNames) {
                const pos = getNodePosition(nodeName);
                const radius = getNodeRadius(nodeName);
                const dist = Math.sqrt(Math.pow(clickX - pos.x, 2) + Math.pow(clickY - pos.y, 2));
                if (dist <= radius + 10) {
                    return nodeName;
                }
            }
            return null;
        }

        // Draw the node network with all connections and nodes
        function drawStickFigure() {
            // Position below player wizard (left side)
            nodeNetwork.centerX = 160;
            nodeNetwork.centerY = canvas.height - 185;

            const cx = nodeNetwork.centerX;
            const cy = nodeNetwork.centerY;

            ctx.save();

            // Draw background panel (scaled up 1.5x)
            ctx.fillStyle = 'rgba(20, 20, 40, 0.7)';
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(cx - 140, cy - 150, 280, 310, 10);
            ctx.fill();
            ctx.stroke();

            // Draw all connections (edges between nodes)
            ctx.strokeStyle = 'rgba(100, 100, 120, 0.6)';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            const drawnEdges = new Set();
            for (const nodeName of allNodeNames) {
                const nodePos = getNodePosition(nodeName);
                const neighbors = nodeNetwork.connections[nodeName] || [];

                for (const neighbor of neighbors) {
                    // Avoid drawing same edge twice
                    const edgeKey = [nodeName, neighbor].sort().join('-');
                    if (drawnEdges.has(edgeKey)) continue;
                    drawnEdges.add(edgeKey);

                    const neighborPos = getNodePosition(neighbor);
                    ctx.beginPath();
                    ctx.moveTo(nodePos.x, nodePos.y);
                    ctx.lineTo(neighborPos.x, neighborPos.y);
                    ctx.stroke();
                }
            }

            // Draw pathway nodes (small grey dots)
            pathwayNodeNames.forEach(nodeName => {
                const pos = getNodePosition(nodeName);
                const radius = getNodeRadius(nodeName);

                // Simple grey dot
                ctx.fillStyle = 'rgba(80, 80, 100, 0.8)';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Subtle outline
                ctx.strokeStyle = 'rgba(120, 120, 140, 0.6)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.stroke();
            });

            // Draw functional nodes (larger, colored)
            functionalNodeNames.forEach(nodeName => {
                const pos = getNodePosition(nodeName);
                const radius = getNodeRadius(nodeName);
                const color = getNodeColor(nodeName);
                const spell = nodeNetwork.spellAssignments[nodeName];
                const state = nodeStates[nodeName] || 'dormant';
                const activationProg = nodeActivationProgress[nodeName] || 0;

                if (state === 'dormant') {
                    // DORMANT: dim, outline only
                    ctx.strokeStyle = hexToRgba(color, 0.4);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Very faint fill
                    ctx.fillStyle = hexToRgba(color, 0.1);
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.fill();

                } else if (state === 'activating') {
                    // ACTIVATING: dim node with circular progress bar
                    ctx.fillStyle = hexToRgba(color, 0.25);
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = hexToRgba(color, 0.5);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Progress bar
                    const progressRadius = radius + 5;
                    const startAngle = -Math.PI / 2;
                    const endAngle = startAngle + (activationProg * Math.PI * 2);

                    ctx.strokeStyle = hexToRgba(color, 0.2);
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, progressRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.strokeStyle = color;
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, progressRadius, startAngle, endAngle);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    ctx.lineCap = 'butt';

                } else if (state === 'active') {
                    // ACTIVE: bright, glowing
                    const glowSize = radius + 10 + Math.sin(animationTime * 4) * 2;
                    const glowGradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, glowSize);
                    glowGradient.addColorStop(0, hexToRgba(color, 0.8));
                    glowGradient.addColorStop(0.4, hexToRgba(color, 0.4));
                    glowGradient.addColorStop(0.7, hexToRgba(color, 0.15));
                    glowGradient.addColorStop(1, hexToRgba(color, 0));
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, glowSize, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = color;
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Label for spell type
                if (spell && spell !== 'dud') {
                    ctx.fillStyle = state === 'active' ? '#fff' : hexToRgba('#fff', 0.4);
                    ctx.font = state === 'active' ? 'bold 10px Georgia' : '9px Georgia';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const label = spell.charAt(0).toUpperCase();
                    ctx.fillText(label, pos.x, pos.y);
                }
            });

            // Draw awareness indicator (pulsing white ring)
            const awPulse = Math.sin(animationTime * 6) * 0.3 + 0.7;
            const currentRadius = awarenessAtNode ? getNodeRadius(awarenessAtNode) : nodeNetwork.pathwayRadius;
            const awSize = currentRadius + 6 + Math.sin(animationTime * 4) * 3;

            // Outer glow
            const awGlow = ctx.createRadialGradient(
                awarenessPos.x, awarenessPos.y, awSize - 4,
                awarenessPos.x, awarenessPos.y, awSize + 12
            );
            awGlow.addColorStop(0, `rgba(255, 255, 255, ${awPulse * 0.5})`);
            awGlow.addColorStop(0.5, `rgba(200, 220, 255, ${awPulse * 0.3})`);
            awGlow.addColorStop(1, 'rgba(200, 220, 255, 0)');
            ctx.fillStyle = awGlow;
            ctx.beginPath();
            ctx.arc(awarenessPos.x, awarenessPos.y, awSize + 12, 0, Math.PI * 2);
            ctx.fill();

            // Bright ring
            ctx.strokeStyle = `rgba(255, 255, 255, ${awPulse})`;
            ctx.lineWidth = 3;
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(awarenessPos.x, awarenessPos.y, awSize, 0, Math.PI * 2);
            ctx.stroke();

            // Inner ring
            ctx.strokeStyle = `rgba(200, 230, 255, ${awPulse * 0.8})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(awarenessPos.x, awarenessPos.y, awSize - 4, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText('BODY NODES', cx, cy - 135);

            ctx.restore();
        }

        // Spell types
        const NEUTRAL = 'neutral';
        const SPIRAL = 'spiral';
        const PULSE = 'pulse';
        const ZAP = 'zap';

        // Colors
        const colors = {
            neutral: '#95a5a6',
            spiral: '#9b59b6',
            pulse: '#e74c3c',
            zap: '#f1c40f'
        };

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Determine winner: returns 1 if a wins, -1 if b wins, 0 if tie
        function getClashResult(a, b) {
            if (a === b) return 0;
            if ((a === SPIRAL && b === ZAP) ||
                (a === ZAP && b === PULSE) ||
                (a === PULSE && b === SPIRAL)) {
                return 1;
            }
            return -1;
        }

        // Enemy AI - sticky random
        function pickNewEnemyBeam() {
            const choices = [SPIRAL, PULSE, ZAP];
            let newBeam;
            do {
                newBeam = choices[Math.floor(Math.random() * choices.length)];
            } while (newBeam === enemyCurrentBeam && enemyCurrentBeam !== null);

            enemyCurrentBeam = newBeam;
            enemyClashesRemaining = 3 + Math.floor(Math.random() * 2);
        }

        function getEnemyChoice() {
            if (enemyCurrentBeam === null || enemyClashesRemaining <= 0) {
                pickNewEnemyBeam();
            }
            return enemyCurrentBeam;
        }

        function showClashResult(text, color) {
            clashResult.textContent = text;
            clashResult.style.color = color;
            clashResult.style.opacity = 1;
            setTimeout(() => {
                clashResult.style.opacity = 0;
            }, 1000);
        }

        function clash() {
            if (!gameActive) return;

            const player = playerChoice || getEnemyChoice();
            const enemy = getEnemyChoice();

            const result = getClashResult(player, enemy);

            let resultText = '';
            let resultColor = 'white';

            if (result === 1) {
                ballPosition = Math.min(100, ballPosition + 10);
                resultText = `${player.toUpperCase()} beats ${enemy.toUpperCase()}! +10%`;
                resultColor = '#2ecc71';
            } else if (result === -1) {
                ballPosition = Math.max(0, ballPosition - 10);
                resultText = `${enemy.toUpperCase()} beats ${player.toUpperCase()}! -10%`;
                resultColor = '#e74c3c';
            } else {
                resultText = `Both chose ${player.toUpperCase()}! TIE`;
                resultColor = '#f1c40f';
            }

            showClashResult(resultText, resultColor);

            const { meterY, clashX } = getBeamPositions();
            clashFlashIntensity = 1;
            lastClashResult = result;
            createClashParticles(clashX, meterY, resultColor);

            enemyClashesRemaining--;

            if (ballPosition <= 0) {
                endGame(false);
            } else if (ballPosition >= 100) {
                endGame(true);
            }
        }

        function endGame(playerWon) {
            gameActive = false;
            gameOverScreen.style.display = 'flex';

            if (playerWon) {
                gameOverScreen.className = 'win';
                gameOverText.textContent = 'Enemy vaporized!';
            } else {
                gameOverScreen.className = 'lose';
                gameOverText.textContent = 'You were vaporized!';
            }
        }

        function restartGame() {
            ballPosition = 50;
            playerChoice = NEUTRAL;
            gameActive = true;
            lastClashTime = performance.now();
            gameOverScreen.style.display = 'none';
            enemyCurrentBeam = null;
            enemyClashesRemaining = 0;
            pickNewEnemyBeam();
            particles = [];
            clashFlashIntensity = 0;
            initStickFigureNodes();
            initNodeStates();
            initStickAwareness();
            initBoostAndCooldowns();
            updateButtonStates();
        }

        function updateButtonStates() {
            neutralBtn.style.outline = playerChoice === NEUTRAL ? '4px solid white' : 'none';
            spiralBtn.style.outline = playerChoice === SPIRAL ? '4px solid white' : 'none';
            pulseBtn.style.outline = playerChoice === PULSE ? '4px solid white' : 'none';
            zapBtn.style.outline = playerChoice === ZAP ? '4px solid white' : 'none';
        }

        function selectSpell(spell) {
            if (!gameActive) return;
            playerChoice = spell;
            updateButtonStates();
        }

        function activateBoost(spell) {
            if (!gameActive) return;

            const now = performance.now();

            // Special rule: Switching TO Neutral has NO cooldown (can always bail to safety)
            if (spell === NEUTRAL) {
                playerBeamType = NEUTRAL;
                playerChoice = NEUTRAL;
                // Clear all cooldowns when going to neutral
                cooldowns.neutral = 0;
                cooldowns.spiral = 0;
                cooldowns.pulse = 0;
                cooldowns.zap = 0;
                updateButtonStates();
                return;
            }

            // For attack types (Spiral/Pulse/Zap):
            // Check if ANY attack cooldown is active
            const attackCooldownActive = cooldowns.spiral > now || cooldowns.pulse > now || cooldowns.zap > now;
            if (attackCooldownActive) return;

            // Commit to this attack beam type
            playerBeamType = spell;

            // Put ALL attack buttons on cooldown (committed for 5 seconds)
            // Neutral never has cooldown
            cooldowns.neutral = 0;
            cooldowns.spiral = now + cooldownDuration;
            cooldowns.pulse = now + cooldownDuration;
            cooldowns.zap = now + cooldownDuration;

            // Also select this spell for visual
            playerChoice = spell;
            updateButtonStates();
        }

        function getEffectiveMana() {
            let effective = playerActiveMana;

            // Add counter modifier based on beam matchup
            const modifier = getCounterModifier();
            effective += modifier;

            // Floor at 0 (can't have negative effective mana)
            return Math.max(0, effective);
        }

        function updateCooldownDisplay() {
            const now = performance.now();
            const maxRemaining = Math.max(
                cooldowns.spiral - now,
                cooldowns.pulse - now,
                cooldowns.zap - now
            );
            const attackOnCooldown = maxRemaining > 0;

            // Handle attack buttons (Spiral, Pulse, Zap)
            [SPIRAL, PULSE, ZAP].forEach(spell => {
                const btn = spell === SPIRAL ? spiralBtn : spell === PULSE ? pulseBtn : zapBtn;
                const isActive = playerBeamType === spell;

                if (attackOnCooldown) {
                    btn.disabled = true;
                    if (isActive) {
                        // This is the active beam
                        btn.textContent = `${spell.toUpperCase()} (${(maxRemaining / 1000).toFixed(1)}s)`;
                        btn.style.opacity = '1';
                        btn.style.outline = '3px solid white';
                    } else {
                        btn.textContent = spell.toUpperCase();
                        btn.style.opacity = '0.4';
                        btn.style.outline = 'none';
                    }
                } else {
                    btn.disabled = false;
                    btn.textContent = spell.toUpperCase();
                    btn.style.opacity = '1';
                    btn.style.outline = isActive ? '3px solid white' : 'none';
                }
            });

            // Neutral button is ALWAYS available (no cooldown to switch to it)
            const neutralActive = playerBeamType === NEUTRAL;
            neutralBtn.disabled = false;
            neutralBtn.textContent = 'NEUTRAL';
            neutralBtn.style.opacity = '1';
            neutralBtn.style.outline = neutralActive ? '3px solid white' : 'none';
        }

        function initBoostAndCooldowns() {
            // Start in NEUTRAL - safe, no modifier
            playerBeamType = NEUTRAL;
            playerChoice = NEUTRAL;
            cooldowns = { neutral: 0, spiral: 0, pulse: 0, zap: 0 };
            // Initialize enemy with a random beam
            switchEnemyBeam();
            updateCooldownDisplay();
        }

        function switchEnemyBeam() {
            // Enemy can use all beam types including neutral
            const beams = [NEUTRAL, SPIRAL, PULSE, ZAP];
            // Pick a different beam than current
            let newBeam;
            do {
                newBeam = beams[Math.floor(Math.random() * beams.length)];
            } while (newBeam === enemyBeamType && enemyBeamType !== null);

            enemyBeamType = newBeam;
            enemyBeamSwitchTime = performance.now() + 4000 + Math.random() * 4000; // 4-8 seconds
        }

        function updateEnemyBeam(timestamp) {
            if (timestamp >= enemyBeamSwitchTime) {
                switchEnemyBeam();
            }
        }

        neutralBtn.addEventListener('click', () => activateBoost(NEUTRAL));
        spiralBtn.addEventListener('click', () => activateBoost(SPIRAL));
        pulseBtn.addEventListener('click', () => activateBoost(PULSE));
        zapBtn.addEventListener('click', () => activateBoost(ZAP));
        restartBtn.addEventListener('click', restartGame);

        // Drawing functions
        function drawBackground() {
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, '#1a1a3a');
            gradient.addColorStop(1, '#0a0a1a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawWizard(x, y, isPlayer, color) {
            ctx.save();
            ctx.translate(x, y);

            ctx.fillStyle = isPlayer ? '#3498db' : '#9b59b6';
            ctx.beginPath();
            ctx.moveTo(0, -30);
            ctx.lineTo(-30, 50);
            ctx.lineTo(30, 50);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(0, -80);
            ctx.lineTo(-25, -30);
            ctx.lineTo(25, -30);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#fad7a0';
            ctx.beginPath();
            ctx.arc(0, -15, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(isPlayer ? 5 : -5, -18, 3, 0, Math.PI * 2);
            ctx.arc(isPlayer ? -5 : 5, -18, 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(isPlayer ? 35 : -35, -20);
            ctx.lineTo(isPlayer ? 50 : -50, 40);
            ctx.stroke();

            ctx.fillStyle = color || '#fff';
            ctx.shadowColor = color || '#fff';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(isPlayer ? 35 : -35, -25, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.restore();
        }

        function drawBeamMeter() {
            const { meterY, clashX } = getBeamPositions();

            const glowSize = 30 + Math.sin(animationTime * 5) * 5;

            const ballGradient = ctx.createRadialGradient(clashX, meterY, 0, clashX, meterY, glowSize);
            ballGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            ballGradient.addColorStop(0.3, 'rgba(100, 200, 255, 0.8)');
            ballGradient.addColorStop(0.6, 'rgba(100, 150, 255, 0.4)');
            ballGradient.addColorStop(1, 'rgba(100, 100, 255, 0)');

            ctx.fillStyle = ballGradient;
            ctx.beginPath();
            ctx.arc(clashX, meterY, glowSize, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(clashX, meterY, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function getBeamPositions() {
            const meterY = canvas.height / 2;
            const playerStartX = 135;
            const enemyStartX = canvas.width - 135;
            const beamLength = enemyStartX - playerStartX;
            const clashX = playerStartX + (ballPosition / 100) * beamLength;
            return { meterY, clashX, playerStartX, enemyStartX, beamLength };
        }

        function getClashProgress() {
            const now = performance.now();
            const elapsed = now - lastClashTime;
            return Math.min(1, elapsed / clashInterval);
        }

        function drawBaseEnergyBeam() {
            const { meterY, clashX, playerStartX, enemyStartX } = getBeamPositions();

            ctx.save();

            // Calculate beam thickness based on active mana
            const playerThickness = getBeamThickness(playerActiveMana);
            const enemyThickness = getBeamThickness(enemyActiveMana);

            const playerColor = colors[playerChoice];
            const playerGradient = ctx.createLinearGradient(playerStartX, 0, clashX, 0);
            const flowOffset = (animationTime * 0.5) % 1;

            for (let i = 0; i < 5; i++) {
                const pos = ((i / 5) + flowOffset) % 1;
                const alpha = 0.15 + Math.sin(pos * Math.PI) * 0.1;
                playerGradient.addColorStop(Math.min(0.99, Math.max(0.01, pos)), hexToRgba(playerColor, alpha));
            }

            ctx.strokeStyle = playerGradient;
            ctx.lineWidth = playerThickness;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(playerStartX, meterY);
            ctx.lineTo(clashX, meterY);
            ctx.stroke();

            const playerCoreGradient = ctx.createLinearGradient(playerStartX, 0, clashX, 0);
            playerCoreGradient.addColorStop(0, hexToRgba(playerColor, 0.4));
            playerCoreGradient.addColorStop(1, hexToRgba(playerColor, 0.2));
            ctx.strokeStyle = playerCoreGradient;
            ctx.lineWidth = playerThickness * 0.35;
            ctx.beginPath();
            ctx.moveTo(playerStartX, meterY);
            ctx.lineTo(clashX, meterY);
            ctx.stroke();

            const playerBeamLength = clashX - playerStartX;
            const playerParticleCount = Math.floor(4 + (playerActiveMana / 6) * 8); // More particles with more mana
            for (let i = 0; i < playerParticleCount; i++) {
                const particleT = ((i / playerParticleCount) + animationTime * 0.8) % 1;
                const px = playerStartX + particleT * playerBeamLength;
                const py = meterY + Math.sin(animationTime * 10 + i * 2) * (playerThickness * 0.25);
                const particleSize = (2 + Math.sin(animationTime * 8 + i) * 1) * (playerThickness / 12);
                const particleAlpha = 0.3 + Math.sin(particleT * Math.PI) * 0.4;

                ctx.fillStyle = hexToRgba(playerColor, particleAlpha);
                ctx.beginPath();
                ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                ctx.fill();
            }

            const enemyColor = colors[enemyBeamType] || '#9b59b6';
            const enemyGradient = ctx.createLinearGradient(enemyStartX, 0, clashX, 0);
            const enemyFlowOffset = (animationTime * 0.5) % 1;

            for (let i = 0; i < 5; i++) {
                const pos = ((i / 5) + enemyFlowOffset) % 1;
                const alpha = 0.15 + Math.sin(pos * Math.PI) * 0.1;
                enemyGradient.addColorStop(Math.min(0.99, Math.max(0.01, 1 - pos)), hexToRgba(enemyColor, alpha));
            }

            ctx.strokeStyle = enemyGradient;
            ctx.lineWidth = enemyThickness;
            ctx.beginPath();
            ctx.moveTo(enemyStartX, meterY);
            ctx.lineTo(clashX, meterY);
            ctx.stroke();

            const enemyCoreGradient = ctx.createLinearGradient(enemyStartX, 0, clashX, 0);
            enemyCoreGradient.addColorStop(0, hexToRgba(enemyColor, 0.4));
            enemyCoreGradient.addColorStop(1, hexToRgba(enemyColor, 0.2));
            ctx.strokeStyle = enemyCoreGradient;
            ctx.lineWidth = enemyThickness * 0.35;
            ctx.beginPath();
            ctx.moveTo(enemyStartX, meterY);
            ctx.lineTo(clashX, meterY);
            ctx.stroke();

            const enemyBeamLength = enemyStartX - clashX;
            const enemyParticleCount = Math.floor(4 + (enemyActiveMana / 6) * 8); // More particles with more mana
            for (let i = 0; i < enemyParticleCount; i++) {
                const particleT = ((i / enemyParticleCount) + animationTime * 0.8) % 1;
                const px = enemyStartX - particleT * enemyBeamLength;
                const py = meterY + Math.sin(animationTime * 10 + i * 2 + Math.PI) * (enemyThickness * 0.25);
                const particleSize = (2 + Math.sin(animationTime * 8 + i + Math.PI) * 1) * (enemyThickness / 12);
                const particleAlpha = 0.3 + Math.sin(particleT * Math.PI) * 0.4;

                ctx.fillStyle = hexToRgba(enemyColor, particleAlpha);
                ctx.beginPath();
                ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                ctx.fill();
            }

            const pulseSize = 15 + Math.sin(animationTime * 6) * 5;
            const clashGlow = ctx.createRadialGradient(clashX, meterY, 0, clashX, meterY, pulseSize);
            clashGlow.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            clashGlow.addColorStop(0.5, 'rgba(255, 255, 255, 0.15)');
            clashGlow.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = clashGlow;
            ctx.beginPath();
            ctx.arc(clashX, meterY, pulseSize, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // SPIRAL BEAM
        function drawSpiralBeam(startX, endX, y, color, isPlayer, thickness = 12) {
            const progress = getClashProgress();
            const length = Math.abs(endX - startX);
            const thicknessScale = thickness / 12; // Scale factor relative to default

            ctx.save();

            const projectileX = isPlayer ?
                startX + progress * length :
                startX - progress * length;

            const traveledLength = Math.abs(projectileX - startX);
            const segments = Math.max(20, Math.floor(traveledLength / 5));
            const amplitude = 15 * thicknessScale;
            const frequency = 0.08;
            const rotationSpeed = 10;

            for (let spiral = 0; spiral < 2; spiral++) {
                const phaseOffset = spiral * Math.PI;
                ctx.beginPath();

                const spiralGradient = isPlayer ?
                    ctx.createLinearGradient(startX, 0, projectileX, 0) :
                    ctx.createLinearGradient(startX, 0, projectileX, 0);
                spiralGradient.addColorStop(0, hexToRgba(color, 0.3));
                spiralGradient.addColorStop(0.7, hexToRgba(color, 0.6));
                spiralGradient.addColorStop(1, hexToRgba(color, 0.8));

                ctx.strokeStyle = spiralGradient;
                ctx.lineWidth = (3 - spiral) * thicknessScale;

                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const x = isPlayer ?
                        startX + t * traveledLength :
                        startX - t * traveledLength;

                    const waveOffset = Math.sin(t * traveledLength * frequency + animationTime * rotationSpeed + phaseOffset) * amplitude;

                    if (i === 0) {
                        ctx.moveTo(x, y + waveOffset);
                    } else {
                        ctx.lineTo(x, y + waveOffset);
                    }
                }
                ctx.stroke();
            }

            const particleCount = Math.floor(4 + thicknessScale * 4);
            for (let i = 0; i < particleCount; i++) {
                const t = (i / particleCount + animationTime * 0.5) % 1;
                const px = isPlayer ?
                    startX + t * traveledLength :
                    startX - t * traveledLength;
                const py = y + Math.sin(t * traveledLength * frequency + animationTime * rotationSpeed) * amplitude;

                ctx.fillStyle = hexToRgba(color, 0.6);
                ctx.beginPath();
                ctx.arc(px, py, 3 * thicknessScale, 0, Math.PI * 2);
                ctx.fill();
            }

            const projectileSize = 20 * thicknessScale;
            const spiralArms = 3;
            const projRotation = animationTime * 15;

            const glowGradient = ctx.createRadialGradient(projectileX, y, 0, projectileX, y, projectileSize * 2);
            glowGradient.addColorStop(0, hexToRgba(color, 0.7));
            glowGradient.addColorStop(0.5, hexToRgba(color, 0.3));
            glowGradient.addColorStop(1, hexToRgba(color, 0));
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(projectileX, y, projectileSize * 2, 0, Math.PI * 2);
            ctx.fill();

            for (let arm = 0; arm < spiralArms; arm++) {
                const armAngle = (Math.PI * 2 * arm) / spiralArms + projRotation;
                ctx.strokeStyle = hexToRgba(color, 0.9);
                ctx.lineWidth = 3 * thicknessScale;
                ctx.beginPath();

                for (let i = 0; i <= 12; i++) {
                    const t = i / 12;
                    const radius = t * projectileSize;
                    const angle = armAngle + t * Math.PI * 2;
                    const px = projectileX + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;

                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();
            }

            ctx.fillStyle = '#fff';
            ctx.shadowColor = color;
            ctx.shadowBlur = 15 * thicknessScale;
            ctx.beginPath();
            ctx.arc(projectileX, y, 7 * thicknessScale, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // ZAP BEAM
        function drawZapBeam(startX, endX, y, color, isPlayer, thickness = 12) {
            const progress = getClashProgress();
            const length = Math.abs(endX - startX);
            const thicknessScale = thickness / 12; // Scale factor relative to default

            ctx.save();

            const projectileX = isPlayer ?
                startX + progress * length :
                startX - progress * length;

            const traveledLength = Math.abs(projectileX - startX);
            const segments = Math.max(15, Math.floor(traveledLength / 8));

            ctx.shadowColor = color;
            ctx.shadowBlur = 10 * thicknessScale;

            const boltGradient = isPlayer ?
                ctx.createLinearGradient(startX, 0, projectileX, 0) :
                ctx.createLinearGradient(startX, 0, projectileX, 0);
            boltGradient.addColorStop(0, hexToRgba(color, 0.4));
            boltGradient.addColorStop(0.5, hexToRgba(color, 0.7));
            boltGradient.addColorStop(1, hexToRgba(color, 0.9));

            ctx.beginPath();
            ctx.strokeStyle = boltGradient;
            ctx.lineWidth = 3 * thicknessScale;

            ctx.moveTo(startX, y);

            for (let i = 1; i <= segments; i++) {
                const t = i / segments;
                const x = isPlayer ?
                    startX + t * traveledLength :
                    startX - t * traveledLength;
                const jitter = (Math.sin(i * 2.7 + animationTime * 35) * 18 +
                              Math.sin(i * 5.3 + animationTime * 55) * 10) * thicknessScale;
                ctx.lineTo(x, y + jitter);
            }
            ctx.stroke();

            ctx.beginPath();
            ctx.strokeStyle = hexToRgba(color, 0.5);
            ctx.lineWidth = 2 * thicknessScale;
            ctx.moveTo(startX, y);

            for (let i = 1; i <= segments; i++) {
                const t = i / segments;
                const x = isPlayer ?
                    startX + t * traveledLength :
                    startX - t * traveledLength;
                const jitter = (Math.cos(i * 3.1 + animationTime * 45) * 22 +
                              Math.sin(i * 6.7 + animationTime * 65) * 12) * thicknessScale;
                ctx.lineTo(x, y + jitter);
            }
            ctx.stroke();

            const sparkCount = Math.floor(6 + thicknessScale * 6);
            for (let i = 0; i < sparkCount; i++) {
                const t = (i / sparkCount + animationTime * 0.3) % 1;
                const sparkX = isPlayer ?
                    startX + t * traveledLength :
                    startX - t * traveledLength;
                const sparkY = y + Math.sin(t * 50 + animationTime * 40 + i * 7) * 20 * thicknessScale;
                const sparkSize = (2 + Math.sin(animationTime * 30 + i * 5) * 1.5) * thicknessScale;

                ctx.fillStyle = hexToRgba(color, 0.7);
                ctx.beginPath();
                ctx.arc(sparkX, sparkY, Math.max(1, sparkSize), 0, Math.PI * 2);
                ctx.fill();
            }

            const projectileSize = 18 * thicknessScale;

            const glowGradient = ctx.createRadialGradient(projectileX, y, 0, projectileX, y, projectileSize * 2.5);
            glowGradient.addColorStop(0, hexToRgba(color, 0.8));
            glowGradient.addColorStop(0.4, hexToRgba(color, 0.4));
            glowGradient.addColorStop(1, hexToRgba(color, 0));
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(projectileX, y, projectileSize * 2.5, 0, Math.PI * 2);
            ctx.fill();

            const boltCount = 8;
            for (let i = 0; i < boltCount; i++) {
                const baseAngle = (Math.PI * 2 * i) / boltCount;
                const angle = baseAngle + Math.sin(animationTime * 25 + i * 4) * 0.4;
                const boltLength = (25 + Math.sin(animationTime * 35 + i * 3) * 12) * thicknessScale;

                ctx.strokeStyle = hexToRgba(color, 0.85);
                ctx.lineWidth = 2 * thicknessScale;
                ctx.beginPath();
                ctx.moveTo(projectileX, y);

                let bx = projectileX;
                let by = y;
                for (let j = 1; j <= 4; j++) {
                    const dist = (boltLength / 4) * j;
                    const jitter = Math.sin(animationTime * 50 + i * 10 + j * 5) * 6 * thicknessScale;
                    bx = projectileX + Math.cos(angle) * dist + Math.cos(angle + Math.PI/2) * jitter;
                    by = y + Math.sin(angle) * dist + Math.sin(angle + Math.PI/2) * jitter;
                    ctx.lineTo(bx, by);
                }
                ctx.stroke();
            }

            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 25 * thicknessScale;
            ctx.beginPath();
            ctx.arc(projectileX, y, 9 * thicknessScale, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ffffaa';
            ctx.beginPath();
            ctx.arc(projectileX, y, 5 * thicknessScale, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // PULSE BEAM
        function drawPulseBeam(startX, endX, y, color, isPlayer, thickness = 12) {
            const progress = getClashProgress();
            const length = endX - startX;
            const thicknessScale = thickness / 12; // Scale factor relative to default

            ctx.save();

            const orbX = isPlayer ?
                startX + progress * length :
                startX - progress * Math.abs(length);

            const trailLength = 50 * thicknessScale;
            const trailStartX = isPlayer ?
                Math.max(startX, orbX - trailLength) :
                Math.min(startX, orbX + trailLength);

            const orbTrailGradient = ctx.createLinearGradient(trailStartX, 0, orbX, 0);
            orbTrailGradient.addColorStop(0, hexToRgba(color, 0));
            orbTrailGradient.addColorStop(1, hexToRgba(color, 0.6));
            ctx.strokeStyle = orbTrailGradient;
            ctx.lineWidth = 8 * thicknessScale;
            ctx.beginPath();
            ctx.moveTo(trailStartX, y);
            ctx.lineTo(orbX, y);
            ctx.stroke();

            const orbSize = (15 + Math.sin(animationTime * 10) * 3) * thicknessScale;

            const glowGradient = ctx.createRadialGradient(orbX, y, 0, orbX, y, orbSize * 2);
            glowGradient.addColorStop(0, hexToRgba(color, 0.8));
            glowGradient.addColorStop(0.5, hexToRgba(color, 0.3));
            glowGradient.addColorStop(1, hexToRgba(color, 0));
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(orbX, y, orbSize * 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.shadowColor = color;
            ctx.shadowBlur = 20 * thicknessScale;
            ctx.beginPath();
            ctx.arc(orbX, y, orbSize * 0.6, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // NEUTRAL BEAM - simple, no special effects
        function drawNeutralBeam(startX, endX, y, color, isPlayer, thickness = 12) {
            const progress = getClashProgress();
            const length = Math.abs(endX - startX);
            const thicknessScale = thickness / 12;

            ctx.save();

            const projectileX = isPlayer ?
                startX + progress * length :
                startX - progress * length;

            const traveledLength = Math.abs(projectileX - startX);

            // Simple straight beam - no fancy effects
            const beamGradient = isPlayer ?
                ctx.createLinearGradient(startX, 0, projectileX, 0) :
                ctx.createLinearGradient(startX, 0, projectileX, 0);
            beamGradient.addColorStop(0, hexToRgba(color, 0.3));
            beamGradient.addColorStop(0.5, hexToRgba(color, 0.5));
            beamGradient.addColorStop(1, hexToRgba(color, 0.7));

            ctx.strokeStyle = beamGradient;
            ctx.lineWidth = 4 * thicknessScale;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(startX, y);
            ctx.lineTo(projectileX, y);
            ctx.stroke();

            // Simple core line
            ctx.strokeStyle = hexToRgba('#ffffff', 0.4);
            ctx.lineWidth = 2 * thicknessScale;
            ctx.beginPath();
            ctx.moveTo(startX, y);
            ctx.lineTo(projectileX, y);
            ctx.stroke();

            // Simple projectile - just a soft glow
            const projectileSize = 12 * thicknessScale;

            const glowGradient = ctx.createRadialGradient(projectileX, y, 0, projectileX, y, projectileSize * 1.5);
            glowGradient.addColorStop(0, hexToRgba(color, 0.6));
            glowGradient.addColorStop(0.5, hexToRgba(color, 0.3));
            glowGradient.addColorStop(1, hexToRgba(color, 0));
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(projectileX, y, projectileSize * 1.5, 0, Math.PI * 2);
            ctx.fill();

            // White center
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(projectileX, y, projectileSize * 0.4, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawBeamByType(beamType, startX, endX, y, color, isPlayer, thickness = 12) {
            switch (beamType) {
                case NEUTRAL:
                    drawNeutralBeam(startX, endX, y, color, isPlayer, thickness);
                    break;
                case SPIRAL:
                    drawSpiralBeam(startX, endX, y, color, isPlayer, thickness);
                    break;
                case ZAP:
                    drawZapBeam(startX, endX, y, color, isPlayer, thickness);
                    break;
                case PULSE:
                    drawPulseBeam(startX, endX, y, color, isPlayer, thickness);
                    break;
                default:
                    drawNeutralBeam(startX, endX, y, color, isPlayer, thickness);
            }
        }

        function drawBeams() {
            const { meterY, clashX, playerStartX, enemyStartX } = getBeamPositions();

            // Calculate beam thickness based on active mana
            const playerThickness = getBeamThickness(playerActiveMana);
            const enemyThickness = getBeamThickness(enemyActiveMana);

            const playerColor = colors[playerChoice];
            drawBeamByType(playerChoice, playerStartX, clashX, meterY, playerColor, true, playerThickness);

            const enemyColor = colors[enemyBeamType] || '#9b59b6';
            if (enemyBeamType) {
                drawBeamByType(enemyBeamType, enemyStartX, clashX, meterY, enemyColor, false, enemyThickness);
            }
        }

        function createClashParticles(x, y, resultColor) {
            const particleCount = 30;
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
                const speed = 3 + Math.random() * 5;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 3 + Math.random() * 4,
                    color: resultColor
                });
            }
        }

        function updateAndDrawParticles() {
            ctx.save();
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1;
                p.life -= p.decay;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }

                ctx.beginPath();
                ctx.fillStyle = hexToRgba(p.color, p.life);
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 10;
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function drawClashFlash() {
            if (clashFlashIntensity > 0) {
                const { meterY, clashX } = getBeamPositions();

                ctx.save();

                let flashColor = '#ffffff';
                if (lastClashResult === 1) flashColor = '#2ecc71';
                else if (lastClashResult === -1) flashColor = '#e74c3c';
                else flashColor = '#f1c40f';

                const ringSize = 80 * (1 - clashFlashIntensity) + 20;
                const ringOpacity = clashFlashIntensity * 0.6;
                ctx.strokeStyle = hexToRgba(flashColor, ringOpacity);
                ctx.lineWidth = 4 * clashFlashIntensity;
                ctx.beginPath();
                ctx.arc(clashX, meterY, ringSize, 0, Math.PI * 2);
                ctx.stroke();

                const ring2Size = 60 * (1 - clashFlashIntensity) + 10;
                ctx.strokeStyle = hexToRgba(flashColor, ringOpacity * 0.7);
                ctx.lineWidth = 3 * clashFlashIntensity;
                ctx.beginPath();
                ctx.arc(clashX, meterY, ring2Size, 0, Math.PI * 2);
                ctx.stroke();

                const coreSize = 40 * clashFlashIntensity;
                const coreGradient = ctx.createRadialGradient(clashX, meterY, 0, clashX, meterY, coreSize);
                coreGradient.addColorStop(0, hexToRgba('#ffffff', clashFlashIntensity * 0.9));
                coreGradient.addColorStop(0.3, hexToRgba(flashColor, clashFlashIntensity * 0.7));
                coreGradient.addColorStop(0.7, hexToRgba(flashColor, clashFlashIntensity * 0.3));
                coreGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(clashX, meterY, coreSize, 0, Math.PI * 2);
                ctx.fill();

                const spikeCount = 8;
                for (let i = 0; i < spikeCount; i++) {
                    const angle = (Math.PI * 2 * i) / spikeCount;
                    const spikeLength = 50 * clashFlashIntensity;
                    const startDist = 15;

                    ctx.strokeStyle = hexToRgba(flashColor, clashFlashIntensity * 0.8);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(
                        clashX + Math.cos(angle) * startDist,
                        meterY + Math.sin(angle) * startDist
                    );
                    ctx.lineTo(
                        clashX + Math.cos(angle) * (startDist + spikeLength),
                        meterY + Math.sin(angle) * (startDist + spikeLength)
                    );
                    ctx.stroke();
                }

                clashFlashIntensity -= 0.04;
                if (clashFlashIntensity < 0) clashFlashIntensity = 0;

                ctx.restore();
            }
        }

        function drawTimer() {
            if (!gameActive) return;

            const manaDiff = getEffectiveMana() - enemyActiveMana;
            const counterMod = getCounterModifier();

            ctx.font = '20px Georgia';
            ctx.textAlign = 'center';

            // Show push status
            let statusText = '';
            let statusColor = '#f1c40f';
            if (manaDiff > 0) {
                statusText = `Pushing! (+${manaDiff} advantage)`;
                statusColor = '#2ecc71';
            } else if (manaDiff < 0) {
                statusText = `Being pushed! (${manaDiff} deficit)`;
                statusColor = '#e74c3c';
            } else {
                statusText = 'Deadlock';
                statusColor = '#f1c40f';
            }

            ctx.fillStyle = statusColor;
            ctx.shadowColor = statusColor;
            ctx.shadowBlur = 10;
            ctx.fillText(statusText, canvas.width / 2, 80);
            ctx.shadowBlur = 0;

            // Show beam matchup in center
            ctx.font = '16px Georgia';
            if (playerBeamType && enemyBeamType) {
                const playerColor = colors[playerBeamType];
                const enemyColor = colors[enemyBeamType];

                // Player beam
                ctx.textAlign = 'right';
                ctx.fillStyle = playerColor;
                ctx.fillText(playerBeamType.toUpperCase(), canvas.width / 2 - 30, 60);

                // VS
                ctx.textAlign = 'center';
                ctx.fillStyle = '#fff';
                ctx.fillText('vs', canvas.width / 2, 60);

                // Enemy beam
                ctx.textAlign = 'left';
                ctx.fillStyle = enemyColor;
                ctx.fillText(enemyBeamType.toUpperCase(), canvas.width / 2 + 30, 60);
            } else if (!playerBeamType) {
                ctx.fillStyle = '#888';
                ctx.fillText('Select a beam type to engage!', canvas.width / 2, 60);
            }
        }

        function drawTitle() {
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 28px Georgia';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10;
            ctx.fillText('WIZARD BEAMS', canvas.width / 2, 40);
            ctx.shadowBlur = 0;
        }

        function drawActiveMana() {
            const effectiveMana = getEffectiveMana();
            const counterMod = getCounterModifier();
            const isCountering = counterMod > 0;
            const isCountered = counterMod < 0;

            // Player active mana (left side)
            ctx.textAlign = 'left';
            ctx.font = 'bold 16px Georgia';

            // Background box for player
            let boxColor = 'rgba(20, 20, 40, 0.8)';
            let borderColor = 'rgba(100, 150, 255, 0.5)';
            if (isCountering) {
                boxColor = 'rgba(30, 60, 30, 0.9)';
                borderColor = 'rgba(100, 255, 100, 0.8)';
            } else if (isCountered) {
                boxColor = 'rgba(60, 30, 30, 0.9)';
                borderColor = 'rgba(255, 100, 100, 0.8)';
            }
            ctx.fillStyle = boxColor;
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = playerBeamType ? 3 : 2;
            ctx.beginPath();
            ctx.roundRect(20, 100, 200, 65, 8);
            ctx.fill();
            ctx.stroke();

            // Player beam type indicator
            if (playerBeamType) {
                const beamColor = colors[playerBeamType];
                ctx.fillStyle = beamColor;
                ctx.shadowColor = beamColor;
                ctx.shadowBlur = 10;
                ctx.fillText(`Beam: ${playerBeamType.toUpperCase()}`, 32, 118);
                ctx.shadowBlur = 0;
            } else {
                ctx.fillStyle = '#888';
                ctx.fillText('Beam: NONE', 32, 118);
            }

            // Player mana with modifier
            ctx.font = 'bold 14px Georgia';
            let manaText = `Mana: ${playerActiveMana}`;
            let manaColor = '#3498db';
            if (counterMod !== 0) {
                const sign = counterMod > 0 ? '+' : '';
                manaText += ` ${sign}${counterMod} = ${effectiveMana}`;
                manaColor = isCountering ? '#2ecc71' : '#e74c3c';
            }
            ctx.fillStyle = manaColor;
            ctx.shadowColor = manaColor;
            ctx.shadowBlur = 8;
            ctx.fillText(manaText, 32, 138);
            ctx.shadowBlur = 0;

            // Counter status
            ctx.font = '12px Georgia';
            if (isCountering) {
                ctx.fillStyle = '#2ecc71';
                ctx.fillText('COUNTERING! (+3)', 32, 155);
            } else if (isCountered) {
                ctx.fillStyle = '#e74c3c';
                ctx.fillText('COUNTERED! (-3)', 32, 155);
            } else if (playerBeamType && enemyBeamType) {
                ctx.fillStyle = '#f1c40f';
                ctx.fillText('NEUTRAL', 32, 155);
            }

            // Enemy active mana (right side)
            ctx.textAlign = 'right';
            ctx.font = 'bold 16px Georgia';

            // Background box for enemy
            ctx.fillStyle = 'rgba(20, 20, 40, 0.8)';
            ctx.strokeStyle = enemyBeamType ? colors[enemyBeamType] : 'rgba(155, 89, 182, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(canvas.width - 220, 100, 200, 65, 8);
            ctx.fill();
            ctx.stroke();

            // Enemy beam type indicator
            if (enemyBeamType) {
                const beamColor = colors[enemyBeamType];
                ctx.fillStyle = beamColor;
                ctx.shadowColor = beamColor;
                ctx.shadowBlur = 10;
                ctx.fillText(`Beam: ${enemyBeamType.toUpperCase()}`, canvas.width - 32, 118);
                ctx.shadowBlur = 0;
            }

            // Enemy mana
            ctx.font = 'bold 14px Georgia';
            ctx.fillStyle = '#9b59b6';
            ctx.shadowColor = '#9b59b6';
            ctx.shadowBlur = 8;
            ctx.fillText(`Mana: ${enemyActiveMana}`, canvas.width - 32, 138);
            ctx.shadowBlur = 0;

            // Show what beats enemy's beam
            ctx.font = '11px Georgia';
            ctx.fillStyle = '#888';
            if (enemyBeamType) {
                let counter = '';
                if (enemyBeamType === NEUTRAL) counter = 'N/A (Neutral)';
                else if (enemyBeamType === SPIRAL) counter = 'PULSE';
                else if (enemyBeamType === PULSE) counter = 'ZAP';
                else if (enemyBeamType === ZAP) counter = 'SPIRAL';
                ctx.fillText(`Counter with: ${counter}`, canvas.width - 32, 155);
            }

            // DEBUG: Show beam sync status
            ctx.textAlign = 'center';
            ctx.font = '10px monospace';
            ctx.fillStyle = '#666';
            ctx.fillText('DEBUG: Beam Sync Check', canvas.width / 2, canvas.height - 20);
            const visualBeam = enemyBeamType ? enemyBeamType.toUpperCase() : 'NONE';
            const calcBeam = enemyBeamType ? enemyBeamType.toUpperCase() : 'NONE';
            const syncStatus = visualBeam === calcBeam ? ' SYNCED' : ' MISMATCH';
            const syncColor = visualBeam === calcBeam ? '#2ecc71' : '#e74c3c';
            ctx.fillStyle = syncColor;
            ctx.fillText(`Visual: ${visualBeam} | Calc: ${calcBeam} | ${syncStatus}`, canvas.width / 2, canvas.height - 6);
        }

        canvas.addEventListener('click', (e) => {
            if (!gameActive) return;

            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Check for stick figure node clicks
            const clickedStickNode = getClickedStickNode(clickX, clickY);
            if (clickedStickNode) {
                moveStickAwarenessTo(clickedStickNode);
            }
        });

        function gameLoop(timestamp) {
            animationTime = timestamp / 1000;

            updateStickAwareness(timestamp);
            updateNodeActivation(timestamp);
            updateCooldownDisplay();
            updateEnemyBeam(timestamp);

            if (gameActive) {
                // Continuous tug-of-war based on active mana difference
                const manaDiff = getEffectiveMana() - enemyActiveMana;
                // Move 1% per second per mana difference
                const pushRate = 1.0; // percent per second per mana diff
                const deltaTime = 1 / 60; // approximate frame time
                const pushAmount = manaDiff * pushRate * deltaTime;

                ballPosition = Math.max(0, Math.min(100, ballPosition + pushAmount));

                // Check win/lose conditions
                if (ballPosition <= 0) {
                    endGame(false);
                } else if (ballPosition >= 100) {
                    endGame(true);
                }
            }

            drawBackground();
            drawBaseEnergyBeam();
            drawBeams();
            drawBeamMeter();
            drawStickFigure();
            drawWizard(100, canvas.height / 2, true, colors[playerChoice]);
            drawWizard(canvas.width - 100, canvas.height / 2, false, colors[enemyBeamType] || '#9b59b6');
            updateAndDrawParticles();
            drawClashFlash();
            drawTimer();
            drawTitle();
            drawActiveMana();

            requestAnimationFrame(gameLoop);
        }

        // Start game
        lastClashTime = performance.now();
        updateButtonStates();
        pickNewEnemyBeam();
        initStickFigureNodes();
        initNodeStates();
        initStickAwareness();
        initBoostAndCooldowns();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
